<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>零碎知识点汇总</title>
    <url>/archives/f5042dfd.html</url>
    <content><![CDATA[<h1 id="零碎知识点汇总"><a href="#零碎知识点汇总" class="headerlink" title="零碎知识点汇总"></a>零碎知识点汇总</h1><blockquote>
<p><em><strong>以下内容均来源于网络</strong></em></p>
</blockquote>
<h3 id="代码编译过程"><a href="#代码编译过程" class="headerlink" title="代码编译过程"></a>代码编译过程</h3><p><a href="https://blog.csdn.net/m0_48022770/article/details/141563549">参考文章 - CSDN</a></p>
<ul>
<li>预处理（预编译）：处理预处理命令并没有真正开始编译（处理<code>#include #define #if</code>等<code>#</code>开头的内容：引用头文件<code>#include</code>、展开宏<code>#define</code>、确定参与编译的代码<code>#if</code>），生成<code>.i</code>文件</li>
<li>编译：将预处理后的代码转换为汇编代码，生成<code>.s</code>文件</li>
<li>汇编：将汇编代码转换为机器码（把汇编语言编译为二进制文件），生成<code>.o</code>文件</li>
<li>链接：将目标文件和库文件结合起来（把多个二进制文件链接为一个整体代码），生成<code>.out .exe</code>等</li>
<li>运行</li>
</ul>
<h3 id="中断服务子程序-ISR"><a href="#中断服务子程序-ISR" class="headerlink" title="中断服务子程序(ISR)"></a>中断服务子程序<code>(ISR)</code></h3><ol>
<li><code>ISR</code>不能返回一个值。</li>
<li><code>ISR</code>不能传递参数。</li>
<li>在许多处理器／编译器中，浮点一般都是不可重入的。<br> 有些处理器／编译器需要让额外的寄存器入栈。<br> 有些处理器／编译器就不允许在<code>IS</code>R中做浮点运算。<br> 此外，<code>ISR</code>应该是短而有效率的，在<code>ISR</code>中做浮点运算是不明智的。</li>
<li>与第三点一脉相承，<code>printf()</code>经常有重入和性能上的问题，所以一般不使用<code>printf()</code>。</li>
</ol>
<h3 id="有符号数与无符号数一起运算"><a href="#有符号数与无符号数一起运算" class="headerlink" title="有符号数与无符号数一起运算"></a>有符号数与无符号数一起运算</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">-20</span>;</span><br><span class="line">	(a+b &gt; <span class="number">6</span>) ? <span class="built_in">puts</span>(<span class="string">&quot;&gt; 6&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;&lt;= 6&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序输出为<code>&quot;&gt; 6&quot;</code>！</p>
<p>原因为：当表达式中同时存在有符号类型和无符号类型时，所有的操作数都自动转换为无符号类型。</p>
<h3 id="EXTERN"><a href="#EXTERN" class="headerlink" title="EXTERN"></a>EXTERN</h3><p><code>extern</code>数组时可以不写元素个数，只在初始化时表明，这样在修改数组元素个数时就只用修改定义的地方，推荐这样写。</p>
<h3 id="数据结构种类"><a href="#数据结构种类" class="headerlink" title="数据结构种类"></a>数据结构种类</h3><p>常用的有9种：基本数据类型、数组、结构体、枚举体、联合体、指针、链表、栈、队列</p>
<h3 id="什么是中断向量表"><a href="#什么是中断向量表" class="headerlink" title="什么是中断向量表"></a>什么是中断向量表</h3><p>问：什么是中断向量表？它在嵌入式系统中如何工作？</p>
<p>答：中断向量表是存储中断服务程序入口地址的表格。<br>当中断发生时，处理器根据中断类型号从中断向量表中找到对应的中断服务程序入口地址并跳转执行相应程序。</p>
<h3 id="简述SPI通信中主机和从机的工作过程"><a href="#简述SPI通信中主机和从机的工作过程" class="headerlink" title="简述SPI通信中主机和从机的工作过程"></a>简述<code>SPI</code>通信中主机和从机的工作过程</h3><p>主机通过<code>SCK</code>线提供时钟信号，在<code>MOSI</code>线上发送数据；<br>从机在<code>SCK</code>上升沿或下降沿采样<code>MOSI</code>数据，同时从机通过<code>MISO</code>线返回数据；<br>主机在相应时钟沿采样<code>MISO</code>线上的数据，片选线<code>CS </code>用于主机选择特定从机，低电平有效。</p>
<h3 id="简述嵌入式系统中-ADC（模拟数字转换器）-的工作原理"><a href="#简述嵌入式系统中-ADC（模拟数字转换器）-的工作原理" class="headerlink" title="简述嵌入式系统中 ADC（模拟数字转换器） 的工作原理"></a>简述嵌入式系统中 <code>ADC</code>（模拟数字转换器） 的工作原理</h3><p><code>ADC</code>将模拟信号转换为数字信号。<br>通过采样保持电路对模拟信号采样并保持，再经量化编码环节将采样值量化为数字量，最后以二进制代码输出。</p>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_DATA  (<span class="string">&quot;!&quot;</span>[0])</span></span><br></pre></td></tr></table></figure>

<p>以上宏定义含义如下：<br><code>(&quot;!&quot;[0])</code>是一个字符串字面量，其中<code>&quot;&quot;</code>是一个包含单个字符<code>!</code>的字符串。</p>
<p>在C语言中，字符串字面量实际上是一个字符数组，每个字符后面跟着一个<code>\0</code>（空字符），用来表示字符串的结束；因此，<code>&quot;!&quot;[0]</code>表示取这个字符串的第一个字符，即<code>!</code></p>
<p>所以， <code>SIG_DATA</code> 被定义为字符<code>!</code></p>
<h3 id="结构体为什么要内存对齐"><a href="#结构体为什么要内存对齐" class="headerlink" title="结构体为什么要内存对齐"></a>结构体为什么要内存对齐</h3><ul>
<li><p><strong>性能优化：</strong><code>CPU</code>访问内存时，通常会以一定的块大小（例如4字节、8字节等）为单位进行读取。如果结构体中的数据成员没有对齐到这样的块边界，<code>CPU</code>可能需要执行额外的操作（如两次内存访问）来读取一个成员，这称为“未对齐访问”。未对齐访问会降低<code>CPU</code>的访问效率，增加程序的执行时间。 内存对齐可以确保结构体中的数据成员都位于合适的块边界上，从而<strong>提高<code>CPU</code>的访问效率。</strong></p>
</li>
<li><p><strong>硬件限制：</strong>某些硬件平台对内存访问有严格的对齐要求。如果结构体中的数据成员没有正确对齐，硬件可能会抛出异常或产生错误的结果。 通过内存对齐，可以确保结构体中的数据成员满足硬件平台的对齐要求，从而<strong>避免潜在的硬件问题</strong>。</p>
</li>
<li><p><strong>可移植性：</strong>不同的编译器和硬件平台可能对内存对齐有不同的要求。如果不进行内存对齐，同一个结构体在不同的编译器或硬件平台上可能会有不同的内存布局和大小。 通过使用标准的数据类型和编译器特定的对齐指令（如<code>#pragma pack</code>），可以确保结构体在不同平台上的内存布局和大小一致，从而<strong>提高程序的可移植性</strong>。</p>
</li>
<li><p><strong>空间利用率：</strong>虽然内存对齐可能会增加结构体所占用的总内存空间（因为编译器会在成员之间插入填充字节以确保对齐），但在某些情况下，这可以提高内存访问的效率并减少缓存未命中的可能性。 此外，合理的内存对齐还可以帮助<strong>减少内存碎片，提高内存管理的效率</strong>。</p>
</li>
<li><p><strong>简化编译器实现：</strong>对于编译器来说，处理未对齐的内存访问需要额外的逻辑和复杂性。通过要求结构体进行内存对齐，可以<strong>简化编译器的实现并减少潜在的错误</strong>。 </p>
</li>
</ul>
<h3 id="内存溢出和内存泄漏的区别"><a href="#内存溢出和内存泄漏的区别" class="headerlink" title="内存溢出和内存泄漏的区别"></a>内存溢出和内存泄漏的区别</h3><p><a href="https://blog.csdn.net/weixin_45080272/article/details/138613786">参考文章 - CSDN</a></p>
<ul>
<li><p>内存溢出：是指程序在申请内存时，没有足够的内存空间供其使用。</p>
<p>  比如，申请了一个整数的内存，但实际存了一个需要<code>long</code>类型来存储的数，这就会导致内存溢出。</p>
<p>  系统无法满足程序需要的内存大小，导致溢出。</p>
</li>
<li><p>内存泄漏：是指程序在申请内存后，无法释放已申请的内存空间。</p>
<p>  虽然单个内存泄漏可能不会带来太大问题，但随着内存泄漏的积累，系统的可用内存空间会逐渐减少；</p>
<p>  <strong>内存泄漏最终可能会导致内存耗尽，也就是内存溢出。</strong></p>
</li>
</ul>
<h3 id="define和typedef区别"><a href="#define和typedef区别" class="headerlink" title="define和typedef区别"></a><code>define</code>和<code>typedef</code>区别</h3><ul>
<li><code>define</code>预处理阶段完成替换，<code>typedef</code>编译阶段进行替换。</li>
<li><code>define</code>没有类型，只是简单的替换，而<code>typedef</code>会进行类型检查</li>
<li><code>define</code>不是语句，不需要加分号，<code>typedef</code>需要加分号</li>
<li>一般<code>define</code>用来定义常量或者书写复杂的内容；<code>typedef</code>一般用于给类型起别名</li>
<li>二者对指针的定义区别很大。</li>
</ul>
<h3 id="const和define的区别"><a href="#const和define的区别" class="headerlink" title="const和define的区别"></a><code>const</code>和<code>define</code>的区别</h3><ul>
<li><strong>数据类型：</strong><code>const</code>修饰的变量有明确的类型，而宏没有明确的数据类型</li>
<li><strong>安全方面：</strong><code>const</code>修饰的变量会被编译器检查，而宏没有安全检查</li>
<li><strong>内存分配：</strong><code>const</code>修饰的变量只会在第一次赋值时分配内存，而宏是直接替换，每次替换后的变量都会分配内存</li>
<li><strong>作用场所：</strong><code>const</code>修饰的变量作用在编译、运行的过程中，而宏作用在预编译中</li>
<li><strong>代码调试：</strong><code>const</code>方便调试，而宏在预编译中进行所以没有办法进行调试。</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>强制类型转换运算符的优先级大于除法</p>
<h3 id="头文件中的ifndef-define-endif的作用"><a href="#头文件中的ifndef-define-endif的作用" class="headerlink" title="头文件中的ifndef/define/endif的作用"></a>头文件中的<code>ifndef/define/endif</code>的作用</h3><p><strong>防止头文件被重复包含（避免重复定义）</strong></p>
<p>如果已经定义了该标识符，就不会再次包含头文件，从而避免重复定义和编译错误；</p>
<p>这样可以确保头文件只被包含一次，提高编译效率并避免潜在的错误。</p>
<h3 id="堆栈溢出一般是由什么原因导致的"><a href="#堆栈溢出一般是由什么原因导致的" class="headerlink" title="堆栈溢出一般是由什么原因导致的"></a>堆栈溢出一般是由什么原因导致的</h3><p>堆栈溢出通常是由<strong>递归调用</strong>或者<strong>过多的嵌套函数调用</strong>导致的。</p>
<p>当一个函数被调用时，其<strong>参数和局部变量会被压入堆栈中</strong>，当函数执行完毕后，这些数据会被弹出堆栈。</p>
<p>如果递归调用或者函数调用过多导致堆栈空间不足，就会发生堆栈溢出。</p>
<p>另外，如果函数内部使用了大量的局部变量或者数组，也有可能导致堆栈溢出。</p>
<h3 id="不能做switch-的参数类型"><a href="#不能做switch-的参数类型" class="headerlink" title="不能做switch()的参数类型"></a>不能做<code>switch()</code>的参数类型</h3><p>只能是整型或字符型。不能是浮点型、字符串等。</p>
<h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><p><strong>可从2方面回答：分配方式、存储位置</strong></p>
<ul>
<li><strong>分配内存的方式</strong></li>
</ul>
<p><strong>堆：</strong>是由程序员分配和释放的，通过内存管理函数（如<code>malloc、free</code>）来操作堆内存。堆内存的生命周期由程序员控制，需要手动释放，否则可能导致内存泄漏。</p>
<p><strong>栈：</strong>是由编译器自动分配和释放的，编译器根据变量的作用域来管理栈内存。当一个函数被调用时，其局部变量存储在栈上，函数执行完成后，这些变量会自动释放。</p>
<ul>
<li><strong>存储方式</strong></li>
</ul>
<p><strong>堆：</strong>是用于存储动态分配的内存，通常用来存储程序中需要长时间保存的大型数据结构，如数组等。堆内存的访问速度较慢，因为需要通过指针来访问。</p>
<p><strong>栈：</strong>是用于存储局部变量和函数调用时的参数，栈内存的访问速度较快，因为数据的存取都在固定的位置进行。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">enum</span> <span class="title">union</span></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">typedef</span> <span class="title">const</span> <span class="title">volatile</span> <span class="title">static</span> <span class="title">extern</span></span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">register</span> </span></span><br></pre></td></tr></table></figure>



<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a><code>sizeof</code></h3><p><code>sizeof</code>不是函数；既是关键字也是运算符</p>
<h3 id="指针与数组的区别"><a href="#指针与数组的区别" class="headerlink" title="指针与数组的区别"></a><strong>指针与数组的区别</strong></h3><p>指针存储地址，数组存储数据；</p>
<p><code>sizeof</code>结果不同（指针返回地址大小，数组返回总字节数）。</p>
<p>如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;1234&quot;</span>; </span><br><span class="line"><span class="type">char</span> p1[] = <span class="string">&quot;1234&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>以上二者有不同吗？如有，有什么不同？</p>
<ul>
<li><code>sizeof(p)</code>和<code>sizeof(p1)</code>得到的结果不同。<code>p</code>是指针，大小为4字节或8字节（取决于系统是32位还是64位）；<code>p1</code>包含结束符号<code>\0</code>所以大小为5字节</li>
<li><code>&amp;p</code>和<code>&amp;p1</code>得到的数据类型不同。<code>&amp;p</code>得到的是“指向指针的指针类型”，<code>&amp;p1</code>得到的是” 指向长度为5的数组的指针类型”</li>
<li>可修改性，由于<code>char* p</code>指向的是字符串常量，所以不能通过<code>p</code>来更改字符串的内容，任何修改字符串的操作都是非法的。而<code>char p1[]</code>是一个字符数组，它的内容可以被修改。</li>
</ul>
<h3 id="简述strcpy、sprintf-、memcpy的区别"><a href="#简述strcpy、sprintf-、memcpy的区别" class="headerlink" title="简述strcpy、sprintf 、memcpy的区别"></a>简述<code>strcpy、sprintf 、memcpy</code>的区别</h3><ul>
<li><p><strong>操作对象不同：</strong><code>strcpy</code> 的两个操作对象均为字符串，<code>sprintf</code>的操作源对象可以是多种数据类型，目的操作对象是字符串，<code>memcpy</code>的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</p>
</li>
<li><p><strong>执行效率不同：</strong><code>memcpy</code>最高，<code>strcpy</code>次之，<code>sprintf</code>的效率最低。</p>
</li>
<li><p><strong>实现功能不同：</strong><code>strcpy</code>主要实现字符串变量间的拷贝；<code>sprintf</code>主要实现其他数据类型格式到字 符串的转化；<code>memcpy</code>主要是内存块间的拷贝。</p>
</li>
</ul>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a><code>DMA</code></h3><p>CPU不参与数据传输（内存↔外设），提升效率。</p>
<p>应用场景：高速ADC采集、大块数据搬运。</p>
<h3 id="优化代码性能方法"><a href="#优化代码性能方法" class="headerlink" title="优化代码性能方法"></a>优化代码性能方法</h3><p>减少函数调用层级、使用查表法替代复杂计算、启用编译器优化（-O2）、内联汇编关键代码。</p>
<h3 id="写一个宏定义SWAP-x-y-，不使用第三个变量交换两个变量的值"><a href="#写一个宏定义SWAP-x-y-，不使用第三个变量交换两个变量的值" class="headerlink" title="写一个宏定义SWAP(x, y)，不使用第三个变量交换两个变量的值"></a>写一个宏定义<code>SWAP(x, y)</code>，不使用第三个变量交换两个变量的值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SWAP(x, y)   do&#123;a^=b;b^=a;a^=b;&#125;while(0)</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">假设 a = <span class="number">3</span>，b = <span class="number">5</span></span><br><span class="line">a -&gt; <span class="number">0011</span></span><br><span class="line">b -&gt; <span class="number">0101</span></span><br><span class="line"></span><br><span class="line">a ^ b</span><br><span class="line"><span class="number">0011</span> ^</span><br><span class="line"><span class="number">0101</span> = <span class="number">0110</span></span><br><span class="line">    </span><br><span class="line">(a ^ b) ^ a = b</span><br><span class="line"><span class="number">0110</span> ^ </span><br><span class="line"><span class="number">0011</span> = <span class="number">0101</span></span><br><span class="line">    </span><br><span class="line">(a ^ b) ^ b = a</span><br><span class="line"><span class="number">0110</span> ^</span><br><span class="line"><span class="number">0101</span> = <span class="number">0011</span></span><br></pre></td></tr></table></figure>



<h3 id="连接符"><a href="#连接符" class="headerlink" title="连接符##"></a>连接符<code>##</code></h3><p>如下例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CON(X, Y) (X##Y)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> a = CON(<span class="number">12</span>, <span class="number">34</span>); <span class="comment">// 结果为 a = 1234;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PinA(x, y) ((x==1) ? set_pin(PIN##y) : reset_pin(PIN##y)) </span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式之串口与RS232与RS485的区别</title>
    <url>/archives/9560aaf1.html</url>
    <content><![CDATA[<p><strong><code>RS232</code>与<code>RS485</code>都是串口通信的变种！</strong></p>
<h2 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h2><p><strong>通信模式：</strong>串行异步全双工</p>
<p><strong>起始位：</strong>由一个逻辑0（低电平）的数据位表示</p>
<p><strong>停止位：</strong>由一个逻辑1（高电平）的数据位表示</p>
<p><strong>空闲状态电平：</strong><code>TX</code>和<code>RX</code>都是高电平（<code>TX</code>、<code>RX</code>上没有任何数据传输时为空闲状态）</p>
<p><strong>波特率：</strong>可以认为是比特率，即每秒传输的位数<code>（bit）</code>。</p>
<p>如：9600<strong>波特率</strong>表示每秒传输9600个符号（即每秒传输9600个高低电平），如果每个符号携带1个比特信息，则<strong>比特率</strong>为<code>9600bit/s</code>；如果每个符号携带2个比特信息，则<strong>比特率</strong>为<code>19200bit/s</code>。</p>
<blockquote>
<p><strong>注：波特率与比特率的区别：</strong></p>
<p>波特率与比特率（Bit Rate）是两个容易混淆的概念：</p>
<ul>
<li>‌<strong>波特率</strong>‌：表示单位时间内传输的符号（码元）数量，单位为波特（Baud）。</li>
<li>‌<strong>比特率</strong>‌：表示单位时间内传输的二进制位数，单位为比特每秒（bit/s）。</li>
</ul>
<p>两者的关系为：‌<strong>比特率 = 波特率 × 单个符号对应的二进制位数</strong>‌。例如，如果每个符号携带2个比特信息，则比特率是波特率的两倍。</p>
</blockquote>
<p><strong>逻辑电平：</strong>采用<code>TTL</code>逻辑，其输出的高电平最小为<code>2.4V（2.4 ~ 5V）</code>，输出的低电平最大为<code>0.4V（0 ~ 0.4V）</code>，一般认为串口通信高电平为<code>5V</code>，低电平为<code>0V</code>。</p>
<p><strong>缺陷：</strong>由于电平逻辑导致其抗干扰能力弱（有静电时可能会导致低电平变为高电平，致使数据出错）；因此通信距离很短（一般为一块电路板上两块芯片间的通信、芯片与电脑通信；距离在1米以内）</p>
<h3 id="UART"><a href="#UART" class="headerlink" title="UART"></a><code>UART</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UART: Universal Asynchronous Receiver/Transmitter 通用异步收发器</span><br></pre></td></tr></table></figure>

<p><code>UART</code>是一种<strong>通用的异步串行通信协议</strong>，它使用起始位、数据位、校验位和停止位来传输数据。</p>
<p>在<code>UART</code>通信中，数据的传输是通过固定的波特率进行的，发送和接收端需要事先约定好波特率、数据位、校验位和停止位等参数。</p>
<h3 id="USART"><a href="#USART" class="headerlink" title="USART "></a><code>USART </code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">USART: Universal Synchronous/Asynchronous Receiver/Transmitter 通用同步/异步串行收发器</span><br></pre></td></tr></table></figure>

<p><code>USART</code>是一种更为复杂的串行通信协议，它<strong>同时支持同步和异步的数据传输方式（通用同步/异步串行收发器）</strong>。</p>
<p>与<code>UART</code>不同的是，<code>USART</code>可以选择同步或者异步模式进行通信，并且提供了更多的控制选项，比如硬件流控制、双向通信等。</p>
<p><code>USART</code>通常用于对数据传输速度要求较高、需要双向通信或者需要更灵活控制的场景。</p>
<h2 id="RS232"><a href="#RS232" class="headerlink" title="RS232"></a><code>RS232</code></h2><p><strong>背景：</strong>为了提高串口通信的距离与稳定性，美国电子工业联盟制定了<code>RS232</code>标准。</p>
<p>那么如何使用<code>RS232</code>进行通信呢？</p>
<p>只需在串口通信的基础上加一个电平转换芯片，如：<code>MAX232</code>，如此便可将<code>TTL</code>转为<code>RS232</code>电平。</p>
<p><strong>逻辑电平：</strong>使用芯片时：如单片机输出给芯片的是<code>5V</code>，则芯片会输出<code>-12V</code>；如单片机输出给芯片的是<code>0V</code>，则芯片会输出<code>+12V</code>（反之亦然）</p>
<blockquote>
<p>注：‌<code>RS232</code>的电平逻辑与<code>TTL</code>不同，<code>RS232</code>采用的是负逻辑。</p>
<p>在<code>RS232</code>标准中，<code>-15V</code>到<code>-3V</code>表示<strong>逻辑“1”</strong>，<code>+3V</code>到<code>+15V</code>表示<strong>逻辑“0”‌</strong></p>
<p><strong>这种电平逻辑的设定是为了提高抗干扰能力</strong></p>
</blockquote>
<p><strong>区别：</strong><code>RS232</code>只改变了电平大小，传输的数据不会被改变。</p>
<p>通信距离可达15米，但传输频率最高只能为<code>2M</code>（即波特率最高为：<code>19200bps</code>）</p>
<h2 id="RS485"><a href="#RS485" class="headerlink" title="RS485"></a><code>RS485</code></h2><p><strong>区别：</strong><code>RS485</code>通信是在串口通信基础上加了一个电平转换芯片，该芯片可将串口信号转为差分信号（反之亦可）</p>
<p><strong>差分信号：</strong>只需要2根线，无需地线；如：信号A大于信号B时代表逻辑1，那么反之就是逻辑0。</p>
<p><strong>差分信号优势：</strong>抗干扰能力强（因为它用两根信号线的差值来代表逻辑0与逻辑1，且两根信号线采用双绞线的方式缠在一起，如果有外界干扰，会使两根信号线的电平一同变化，那么二者之间的差值基本保持不变）；传输距离远（可达1200米）；传输频率高（可达<code>50M</code>）</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/CSDN_PBB/article/details/131102031">CSDN - UART与USART</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2355943?policyId=1004">腾讯云开发者社区 - MCU常见通信总线串讲（一） UART和USART</a></p>
<p><a href="https://www.bilibili.com/video/BV1PD4y147ts">B站视频  爱上半导体 - 5分钟看懂!串口RS232 RS485最本质的区别！</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机中断执行流程</title>
    <url>/archives/706f150e.html</url>
    <content><![CDATA[<h2 id="中断执行流程"><a href="#中断执行流程" class="headerlink" title="中断执行流程"></a>中断执行流程</h2><h3 id="一、中断触发阶段"><a href="#一、中断触发阶段" class="headerlink" title="一、中断触发阶段"></a>一、中断触发阶段</h3><h4 id="1-中断源触发"><a href="#1-中断源触发" class="headerlink" title="1. 中断源触发"></a>1. 中断源触发</h4><ul>
<li><strong>硬件事件</strong>：<code>GPIO</code>输入、定时器溢出、<code>ADC</code>转换完成等。</li>
<li><strong>软件事件</strong>：软件中断指令（如<code>SWI - SoftWare Interrupt</code>）。</li>
</ul>
<h4 id="2-中断请求（IRQ）发送"><a href="#2-中断请求（IRQ）发送" class="headerlink" title="2. 中断请求（IRQ）发送"></a>2. 中断请求（<code>IRQ</code>）发送</h4><ul>
<li>外设将中断标志位置1，并向<code>NVIC</code>（嵌套向量中断控制器）发送请求。</li>
<li><code>NVIC</code>根据优先级决定是否立即响应。</li>
</ul>
<h3 id="二、中断响应阶段"><a href="#二、中断响应阶段" class="headerlink" title="二、中断响应阶段"></a>二、中断响应阶段</h3><h4 id="1-处理器上下文保存"><a href="#1-处理器上下文保存" class="headerlink" title="1. 处理器上下文保存"></a>1. 处理器上下文保存</h4><ul>
<li><strong>自动压栈</strong>（硬件完成）：<ul>
<li>当前程序计数器（<code>PC</code>）、程序状态寄存器（<code>xPSR</code>）、通用寄存器（<code>R0-R3, R12, LR</code>）依次压入当前堆栈（<code>MSP/PSP</code>）。</li>
<li>若中断嵌套发生，自动切换到主堆栈（<code>MSP</code>）。</li>
</ul>
</li>
<li><strong>LR值更新</strong>：<code>LR</code>被设置为特殊值（如<code>0xFFFFFFF1</code>），标记中断返回模式。</li>
</ul>
<h4 id="2-中断向量表查找"><a href="#2-中断向量表查找" class="headerlink" title="2. 中断向量表查找"></a>2. 中断向量表查找</h4><ul>
<li><p>处理器根据中断号（<code>IRQn</code>）计算向量表偏移：</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">中断服务函数地址 = VTOR（向量表基址） + <span class="number">4</span> * (IRQn + <span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>例如：<code>IRQn=10</code>，其地址 = <code>0x8000000 + 4 * (10 + 16) = 0x8000068</code></li>
</ul>
</li>
</ul>
<h4 id="3-跳转到中断服务函数（ISR）"><a href="#3-跳转到中断服务函数（ISR）" class="headerlink" title="3. 跳转到中断服务函数（ISR）"></a><strong>3. 跳转到中断服务函数（<code>ISR</code>）</strong></h4><ul>
<li>处理器从向量表中读取<code>ISR</code>地址，并跳转执行。</li>
</ul>
<p><strong>注：</strong></p>
<ul>
<li><p><strong><code>ISR</code>不能返回一个值。</strong></p>
</li>
<li><p><strong><code>ISR</code>不能传递参数。</strong></p>
</li>
<li><p><strong>在许多处理器／编译器中，浮点一般都是不可重入的。有些处理器／编译器需要让额外的寄存器入栈。有些处理器／编译器就不允许在ISR中做浮点运算。此外，<code>ISR</code>应该是短而有效率的，在<code>ISR</code>中做浮点运算是不明智的。</strong></p>
</li>
<li><p><strong>与第三点一脉相承，<code>printf()</code>经常有重入和性能上的问题，所以一般不使用<code>printf()</code>。</strong></p>
</li>
</ul>
<h3 id="三、中断处理阶段"><a href="#三、中断处理阶段" class="headerlink" title="三、中断处理阶段"></a>三、中断处理阶段</h3><h4 id="1-ISR执行流程"><a href="#1-ISR执行流程" class="headerlink" title="1. ISR执行流程"></a>1. <code>ISR</code>执行流程</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 清除中断标志（防止重复进入）</span></span><br><span class="line">    TIM1-&gt;SR &amp;= ~TIM_SR_CC1IF;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 用户处理逻辑（如读取ADC数据、翻转GPIO等）</span></span><br><span class="line">    do_something();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 若有更高优先级中断，可触发上下文切换（如PendSV）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-关键注意事项"><a href="#2-关键注意事项" class="headerlink" title="2. 关键注意事项"></a>2. 关键注意事项</h4><ul>
<li><strong>快速响应</strong>：<code>ISR</code>应尽量简短，避免长时间阻塞。</li>
<li><strong>共享资源保护</strong>：若需访问全局变量，使用临界区（关中断）或原子操作。</li>
</ul>
<h3 id="四、中断返回阶段"><a href="#四、中断返回阶段" class="headerlink" title="四、中断返回阶段"></a>四、中断返回阶段</h3><h4 id="1-上下文恢复"><a href="#1-上下文恢复" class="headerlink" title="1. 上下文恢复"></a>1. 上下文恢复</h4><ul>
<li><strong>出栈操作</strong>（硬件自动完成）：<ul>
<li>从堆栈中依次恢复<code>R0-R3, R12, LR, PC, xPSR</code>。</li>
</ul>
</li>
<li><strong>LR值检查</strong>：若<code>LR=0xFFFFFFF1</code>，表示返回线程模式并使用<code>MSP</code>。</li>
</ul>
<h4 id="2-返回原程序"><a href="#2-返回原程序" class="headerlink" title="2. 返回原程序"></a>2. 返回原程序</h4><ul>
<li>处理器恢复之前的<code>PC</code>和<code>xPSR</code>，继续执行被中断的代码。</li>
</ul>
<h3 id="五、完整流程示意图"><a href="#五、完整流程示意图" class="headerlink" title="五、完整流程示意图"></a>五、完整流程示意图</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────────────────┐</span><br><span class="line">│     主程序运行          │</span><br><span class="line">└──────────┬───────────┘</span><br><span class="line">           │ 中断触发</span><br><span class="line">┌──────────▼───────────┐</span><br><span class="line">│ 硬件自动保存上下文      │</span><br><span class="line">│ (PC, xPSR, R0-R3等)   │</span><br><span class="line">└──────────┬───────────┘</span><br><span class="line">           │</span><br><span class="line">┌──────────▼───────────┐</span><br><span class="line">│ 从向量表获取ISR地址     │</span><br><span class="line">└──────────┬───────────┘</span><br><span class="line">           │</span><br><span class="line">┌──────────▼───────────┐</span><br><span class="line">│ 执行ISR               │</span><br><span class="line">│ 1. 清除中断标志        │</span><br><span class="line">│ 2. 处理中断任务        │</span><br><span class="line">└──────────┬───────────┘</span><br><span class="line">           │</span><br><span class="line">┌──────────▼───────────┐</span><br><span class="line">│ 硬件自动恢复上下文      │</span><br><span class="line">└──────────┬───────────┘</span><br><span class="line">           │</span><br><span class="line">┌──────────▼───────────┐</span><br><span class="line">│ 返回主程序继续执行      │</span><br><span class="line">└───────────────────────┘</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="中断嵌套与优先级"><a href="#中断嵌套与优先级" class="headerlink" title="中断嵌套与优先级"></a>中断嵌套与优先级</h2><h3 id="1-优先级规则"><a href="#1-优先级规则" class="headerlink" title="1. 优先级规则"></a>1. 优先级规则</h3><ul>
<li><strong>抢占优先级</strong>：高优先级可打断低优先级。</li>
<li><strong>子优先级</strong>：相同抢占优先级时，按子优先级顺序执行。</li>
</ul>
<h3 id="2-嵌套中断流程"><a href="#2-嵌套中断流程" class="headerlink" title="2. 嵌套中断流程"></a>2. 嵌套中断流程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">低优先级ISR执行中</span><br><span class="line">   ↓</span><br><span class="line">高优先级中断触发</span><br><span class="line">   ↓</span><br><span class="line">硬件保存低优先级ISR的上下文</span><br><span class="line">   ↓</span><br><span class="line">执行高优先级ISR</span><br><span class="line">   ↓</span><br><span class="line">高优先级ISR返回，恢复低优先级ISR上下文</span><br><span class="line">   ↓</span><br><span class="line">低优先级ISR继续执行</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>中断</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机的存储空间与内存分区</title>
    <url>/archives/dcc8860b.html</url>
    <content><![CDATA[<h1 id="ROM、RAM、FLASH与内存分区"><a href="#ROM、RAM、FLASH与内存分区" class="headerlink" title="ROM、RAM、FLASH与内存分区"></a><code>ROM</code>、<code>RAM</code>、<code>FLASH</code>与内存分区</h1><h2 id="一、物理存储介质"><a href="#一、物理存储介质" class="headerlink" title="一、物理存储介质"></a>一、物理存储介质</h2><ol>
<li><p><strong><code>ROM（Read-Only Memory）</code>- 只读存储器</strong>  </p>
<ul>
<li><strong>特性</strong>：非易失性存储器，内容出厂固化，不可修改<strong>（现代系统中常被<code>FLASH</code>替代）</strong>。  </li>
<li><strong>用途</strong>：存储<code>BootLoader</code>、固定配置数据。  </li>
</ul>
</li>
<li><p><strong><code>FLASH</code></strong>  </p>
<ul>
<li><strong>特性</strong>：非易失性存储器、可擦写。</li>
<li><strong>用途</strong>：存储程序代码（<code>.text</code>）、常量（<code>.rodata</code>）、中断向量表。  </li>
</ul>
</li>
<li><p><strong><code>RAM（Random Access Memory）</code>- 随机存取存储器</strong>  </p>
<ul>
<li><strong>特性</strong>：易失性存储器、高速读写，断电数据丢失。  </li>
<li><strong>用途</strong>：存储运行时数据（堆、栈、全局变量、动态内存）。  </li>
</ul>
</li>
</ol>
<h2 id="二、程序内存分区"><a href="#二、程序内存分区" class="headerlink" title="二、程序内存分区"></a>二、程序内存分区</h2><ol>
<li><strong>代码区（<code>.text</code>段）</strong>  <ul>
<li><strong>位置</strong>：<code>FLASH</code>中。  </li>
<li><strong>内容</strong>：编译后的机器指令（函数代码）、字符串常量也有可能存放在该区。  </li>
<li><strong>示例</strong>：见文末。</li>
</ul>
</li>
<li><strong>只读数据（常量）区（<code>.rodata</code>段）</strong>  <ul>
<li><strong>位置</strong>：<code>FLASH</code>中。  </li>
<li><strong>内容</strong>：<code>const</code>修饰的全局/静态常量、字符串。  </li>
<li><strong>示例</strong>：见文末。</li>
</ul>
</li>
<li><strong>全局区/静态存储区</strong>  <ul>
<li><strong>全局区有<code>.bss</code>段和<code>.data</code>段组成，可读可写；位与<code>RAM</code>中。</strong></li>
<li><strong>位置</strong>：  <ul>
<li><strong><code>.bss</code>段 - 启动时清零</strong><ul>
<li>未初始化的全局变量、初始化为0的全局变量、初始化为0的静态变量。</li>
<li><code>.bss</code>段不占用可执行文件空间，启动时由操作系统清零。</li>
</ul>
</li>
<li><strong><code>.data</code>段 - 初始值从<code>FLASH</code>加载</strong><ul>
<li>已经初始化的全局变量、已经初始化的静态变量（<code>static</code>修饰）。</li>
<li><code>.data</code>段占用可执行文件空间，其内容由程序（程序员）初始化。</li>
</ul>
</li>
</ul>
</li>
<li><strong>示例</strong>：见文末。</li>
</ul>
</li>
<li><strong>栈区（<code>Stack</code>）</strong>  <ul>
<li><strong>位置</strong>：<code>RAM</code>中，由编译器自动管理。  </li>
<li><strong>内容</strong>：函数内临时创建的局部变量、函数参数、函数返回值、<code>const</code>定义的局部变量。  </li>
<li><strong>特点</strong>：<code>LIFO</code>（后进先出），大小固定（可能溢出）。  </li>
<li><strong>示例：</strong>见文末。</li>
</ul>
</li>
<li><strong>堆区（<code>Heap</code>）</strong>  <ul>
<li><strong>位置</strong>：<code>RAM</code>中，位于<code>.bss</code>段末尾和栈区之间。  </li>
<li><strong>内容</strong>：动态分配的内存（<code>malloc</code>/<code>free</code>）。  </li>
<li><strong>特点</strong>：手动管理，需防止内存泄漏。  </li>
<li><strong>示例</strong>：见文末。</li>
</ul>
</li>
</ol>
<h3 id="IAR与KEIL输出的文件信息"><a href="#IAR与KEIL输出的文件信息" class="headerlink" title="IAR与KEIL输出的文件信息"></a><code>IAR</code>与<code>KEIL</code>输出的文件信息</h3><p><strong><code>IAR:</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MAP文件信息：</span><br><span class="line"><span class="number">29608</span> bytes of readonly  code memory   [代码，存储于 Flash]</span><br><span class="line"> <span class="number">1360</span> bytes of readonly  data memory   [常量，存储于 Flash]</span><br><span class="line"> <span class="number">4142</span> bytes of readwrite data memory   [变量，存储于 RAM]</span><br></pre></td></tr></table></figure>



<p><strong><code>KEIL:</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Build Output输出信息：</span><br><span class="line">Program Size: Code=<span class="number">32728</span> RO-data=<span class="number">368</span> RW-data=<span class="number">760</span> ZI-data=<span class="number">3664</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 在以上数据中：</span><br><span class="line">- Code: 存储代码；   [代码，存储于 Flash]</span><br><span class="line">- Ro-data(Read Only): 存储只读常量，如<span class="type">const</span>修饰的变量；   [常量，存储于 Flash]</span><br><span class="line">- RW-data(Read Write): 存储已初始化的读写变量；   [变量，存储于 RAM]</span><br><span class="line">- ZI-data(Zero Initialze): 存储未初始化或初始化为零的变量；   [变量，存储于 RAM]</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> MAP文件信息：</span><br><span class="line">Total RO  Size (Code + RO Data)             <span class="number">33096</span> (<span class="number">32.32</span>KB)</span><br><span class="line">Total RW  Size (RW Data + ZI Data)          <span class="number">4424</span>  ( <span class="number">4.32</span>KB)</span><br><span class="line">Total ROM Size (Code + RO Data + RW Data)   <span class="number">33400</span> (<span class="number">32.62</span>KB)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 总结：</span><br><span class="line">RAM = RW Data + ZI Data</span><br><span class="line">ROM/Flash = Code + RW Data + RO Data</span><br></pre></td></tr></table></figure>



<h2 id="三、协作流程与联系"><a href="#三、协作流程与联系" class="headerlink" title="三、协作流程与联系"></a>三、协作流程与联系</h2><ol>
<li><strong>程序启动阶段</strong>  <ul>
<li><strong><code>FLASH</code>加载</strong>：<code>CPU</code>从<code>FLASH</code>的<code>0x8000000</code>读取中断向量表，执行<code>Reset_Handler</code>。  </li>
<li><strong><code>RAM</code>初始化</strong>：  <ul>
<li>将<code>FLASH</code>中的<code>.data</code>段初始值复制到<code>RAM</code>。  </li>
<li>清零<code>RAM</code>中的<code>.bss</code>段。  </li>
</ul>
</li>
<li><strong>堆栈初始化</strong>：  <ul>
<li>根据链接脚本设置堆（<code>_heap_start</code>）和栈（<code>_stack_top</code>）的起始地址。</li>
</ul>
</li>
</ul>
</li>
<li><strong>运行时交互</strong>  <ul>
<li><strong>代码执行</strong>：<code>CPU</code>从<code>FLASH</code>的<code>.text</code>段读取指令。  </li>
<li><strong>数据访问</strong>：  <ul>
<li>全局变量从<code>RAM</code>的<code>.data</code>或<code>.bss</code>段读写。  </li>
<li>常量从<code>FLASH</code>的<code>.rodata</code>段读取。  </li>
</ul>
</li>
<li><strong>函数调用</strong>：  <ul>
<li>局部变量在栈区动态分配。  </li>
<li>递归调用过深可能导致栈溢出<code>（Stack Overflow）</code>。  </li>
</ul>
</li>
<li><strong>动态内存</strong>：通过堆区分配，需手动管理生命周期。</li>
</ul>
</li>
<li><strong>中断处理</strong>  <ul>
<li><strong>栈切换</strong>：中断触发时，自动使用主栈指针（<code>MSP</code>）或进程栈指针（<code>PSP</code>）。  </li>
<li><strong>上下文保存</strong>：寄存器和返回地址压入栈区。</li>
</ul>
</li>
</ol>
<h2 id="四、内存布局图示"><a href="#四、内存布局图示" class="headerlink" title="四、内存布局图示"></a>四、内存布局图示</h2><p><img src="https://s2.loli.net/2025/04/02/d2QvbqJIgiZGL9O.png" alt=".png"></p>
<h2 id="五、差异总结"><a href="#五、差异总结" class="headerlink" title="五、差异总结"></a>五、差异总结</h2><table>
<thead>
<tr>
<th>区域</th>
<th>存储介质</th>
<th>内容</th>
<th>管理方式</th>
<th>生命周期</th>
</tr>
</thead>
<tbody><tr>
<td>代码区 (.text)</td>
<td>FLASH</td>
<td>程序指令、常量字符串</td>
<td>编译器自动分配</td>
<td>永久</td>
</tr>
<tr>
<td>.rodata</td>
<td>FLASH</td>
<td>只读全局常量</td>
<td>编译器自动分配</td>
<td>永久</td>
</tr>
<tr>
<td>.data</td>
<td>RAM</td>
<td>已初始化全局/静态变量</td>
<td>启动时从FLASH加载</td>
<td>程序运行期</td>
</tr>
<tr>
<td>.bss</td>
<td>RAM</td>
<td>未初始化全局/静态变量</td>
<td>启动时清零</td>
<td>程序运行期</td>
</tr>
<tr>
<td>堆区 (Heap)</td>
<td>RAM</td>
<td>动态分配内存</td>
<td>手动分配/释放</td>
<td>直到free调用</td>
</tr>
<tr>
<td>栈区 (Stack)</td>
<td>RAM</td>
<td>局部变量、函数上下文</td>
<td>编译器自动分配</td>
<td>函数调用期间</td>
</tr>
</tbody></table>
<h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><ol>
<li><p><strong>FLASH和ROM的区别？</strong>  </p>
<ul>
<li>ROM是只读存储器，FLASH是可擦写的非易失存储器，现代嵌入式系统中FLASH取代了ROM。</li>
</ul>
</li>
<li><p><strong>全局变量和静态变量何时初始化？</strong>  </p>
<ul>
<li>初始化的全局/静态变量在启动时从FLASH加载到RAM的<code>.data</code>段；未初始化的在<code>.bss</code>段，启动时清零。</li>
</ul>
</li>
<li><p><strong>堆和栈溢出如何检测？</strong>  </p>
<ul>
<li><strong>栈溢出</strong>：通过编译器选项（如<code>GCC</code>的<code>-fstack-protector</code>）或硬件<code>MPU</code>保护。  </li>
<li><strong>堆溢出</strong>：需工具检测（如<code>Valgrind</code>）或自定义内存管理。</li>
</ul>
</li>
<li><p><strong>中断向量表为何必须放在FLASH起始地址？</strong>  </p>
<ul>
<li><code>CPU</code>上电后从固定地址（如<code>STM32</code>的<code>0x08000000</code>）读取向量表，若重映射需配置<code>SCB-&gt;VTOR</code>。</li>
</ul>
</li>
</ol>
<h2 id="七、附录"><a href="#七、附录" class="headerlink" title="七、附录"></a>七、附录</h2><h3 id="数据存放位置示例"><a href="#数据存放位置示例" class="headerlink" title="数据存放位置示例"></a>数据存放位置示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义和枚举常量会被当成代码编译进代码段，不占空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"></span><br><span class="line">typrdef <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	RED,</span><br><span class="line">	GREEN,</span><br><span class="line">	BLUE</span><br><span class="line">&#125;COLOR_ENUM;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> val1 = <span class="number">1</span>; <span class="comment">//val1存放在.data段</span></span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val2 = <span class="number">1</span>; <span class="comment">//初始化的全局变量存放在.data段</span></span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val3 ; <span class="comment">//未初始化的全局变量存放在.bss段</span></span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> val4 = <span class="number">1</span>;  <span class="comment">//val4存放在.rodata（只读数据段）</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">Demo</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num)</span> <span class="comment">// num 存放在栈区</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> var = <span class="string">&quot;123456&quot;</span>;    <span class="comment">// var存放在栈区，&quot;123456&quot;存放在常量区</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num1 = <span class="number">1</span> ; <span class="comment">// num1存放在栈区</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> num2 = <span class="number">0</span>; <span class="comment">// num2存放在.data段</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> num3 = <span class="number">7</span>;  <span class="comment">//num3存放在栈区</span></span><br><span class="line"> </span><br><span class="line">	<span class="type">void</span> *p;</span><br><span class="line">	</span><br><span class="line">	p = <span class="built_in">malloc</span>(<span class="number">8</span>); <span class="comment">//p存放在堆区</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">0</span> ;</span><br><span class="line">	num = Demo(num); <span class="comment">//Demo()函数的返回值存放在栈区。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://zyxbeyourself.blog.csdn.net/article/details/131945593">CSDN - RAM明明断电会丢失数据，为什么初始化的全局变量存储在RAM？详细分析程序的存储</a></li>
</ul>
<ul>
<li><a href="https://www.cnblogs.com/zyzmlc/p/14078056.html">博客园 - 内存五大区：（栈、堆、全局静态区、常量区、代码区）（线程、函数栈、栈帧）</a></li>
</ul>
<ul>
<li><a href="https://blog.csdn.net/Teminator_/article/details/141786133">CSDN - 单片机内存区域划分</a></li>
</ul>
<ul>
<li><a href="https://blog.csdn.net/Vista7Malone/article/details/144636528">CSDN - RAM、SRAM、DRAM、SDRAM、DDR、ROM、PROM、EPROM、EEPROM、NAND FLASH、NOR FLASH傻傻分不清楚？一文讲清它们的区别</a></li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机启动过程解析</title>
    <url>/archives/db73c4af.html</url>
    <content><![CDATA[<h2 id="单片机启动过程解析"><a href="#单片机启动过程解析" class="headerlink" title="单片机启动过程解析"></a>单片机启动过程解析</h2><h3 id="一、正常程序运行流程"><a href="#一、正常程序运行流程" class="headerlink" title="一、正常程序运行流程"></a>一、正常程序运行流程</h3><img src="https://s2.loli.net/2025/04/01/PdL4Sw1U9p3sDgl.png" alt=".png" style="zoom:67%;" />

<ol>
<li><p><strong>初始化阶段</strong></p>
<ul>
<li><strong>MSP初始化</strong>：上电后处理器从<code>0x8000000</code>地址读取主堆栈指针<code>（MSP）</code>初始值（占据<code>0x8000000~0x8000003</code>）。</li>
<li><strong>PC跳转</strong>：从<code>0x8000004</code>地址读取复位中断向量值，程序计数器<code>（PC）</code>跳转至该地址。</li>
</ul>
</li>
<li><p><strong>复位中断处理</strong></p>
<ul>
<li><strong>关键操作</strong>：<code>Reset_Handler</code>依次执行：<ul>
<li>初始化系统时钟（<code>SystemInit</code>）</li>
<li>将<code>.data</code>段从<code>Flash</code>复制到<code>RAM</code></li>
<li>清零<code>.bss</code>段</li>
<li>调用<code>__main</code>（完成<code>C库</code>初始化）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>用户程序执行</strong></p>
<ul>
<li>跳转至<code>main</code>函数执行用户代码。</li>
<li><strong>中断机制</strong>：无中断时运行主循环；中断触发时通过中断向量表跳转至对应服务程序，执行后返回断点继续运行。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、中断向量表机制"><a href="#二、中断向量表机制" class="headerlink" title="二、中断向量表机制"></a>二、中断向量表机制</h3><ul>
<li><strong>地址计算</strong>：<code>中断向量地址 = 0x8000000 + 4 * (IRQn + 16)</code><ul>
<li><em>注：之所以可以找到复位中断程序，是因为中断向量表占据的是从<code>0x8000000</code>起始的连续空间，且每个中断占4字节，按固定顺序存放在表中。</em></li>
<li><em>注：不同芯片厂商可能采用不同偏移规则（如<code>STM32</code>复位向量位于第2项），需以具体手册为准。</em></li>
</ul>
</li>
<li><strong>异常处理</strong>：复位中断<code>（IRQn=-15）</code>位于向量表第1项，地址为<code>0x8000004</code>。</li>
</ul>
<hr>
<h3 id="三、加入IAP后的启动流程"><a href="#三、加入IAP后的启动流程" class="headerlink" title="三、加入IAP后的启动流程"></a>三、加入<code>IAP</code>后的启动流程</h3><img src="https://s2.loli.net/2025/04/01/n1itPdDYqV64BWH.png" alt="IAP.png" style="zoom:67%;" />

<ol>
<li><p><strong><code>BootLoader</code>阶段</strong></p>
<ul>
<li>上电后执行<code>IAP</code>的<code>Reset_Handler</code>，跳转至<code>IAP</code>的<code>main</code>函数。</li>
<li>完成固件接收、校验、写入等操作。</li>
</ul>
</li>
<li><p><strong>跳转至应用程序</strong></p>
<ul>
<li><strong>无需复位</strong>：<code>IAP</code>直接跳转至<code>APP</code>入口（如<code>0x8003000</code>）。</li>
<li><strong>关键操作</strong>：<ul>
<li>重设<code>MSP</code>：从<code>APP</code>起始地址读取新<code>MSP</code>值。</li>
<li>重映射向量表：<code>SCB-&gt;VTOR = 0x8003000;</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>应用程序执行</strong></p>
<ul>
<li>执行<code>APP</code>的<code>Reset_Handler</code>，流程同正常启动。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="四、关键注意事项"><a href="#四、关键注意事项" class="headerlink" title="四、关键注意事项"></a>四、关键注意事项</h3><ol>
<li><p><strong>向量表重映射</strong></p>
<ul>
<li><p><strong><code>GD32F330</code>特性</strong>：<code>SystemInit()</code>默认设置<code>VTOR</code>，用户需在其后重设：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SystemInit();          <span class="comment">// 库函数可能覆盖VTOR</span></span><br><span class="line">SCB-&gt;VTOR = APP_ADDR; <span class="comment">// 需在SystemInit之后设置</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>低功耗唤醒</strong>：部分芯片唤醒后<code>VTOR</code>复位，需重新配置。</p>
</li>
<li><p><strong>其他芯片</strong>：使用任何芯片在设置<code>VTOR</code>前都应先查看是否有其他地方已经设置过了！</p>
</li>
</ul>
</li>
<li><p><strong>跨厂商差异</strong></p>
<ul>
<li><code>STM32</code>的复位向量为向量表第2项（地址<code>0x8000004</code>）。</li>
<li>需查阅芯片参考手册确认中断向量偏移规则。</li>
</ul>
</li>
<li><p><strong><code>IAP</code>设计要点</strong></p>
<ul>
<li><strong>跳转前准备</strong>：关闭所有中断，清理外设状态。</li>
<li><strong>地址对齐</strong>：<code>APP</code>起始地址需满足芯片的<code>Flash</code>扇区对齐要求。</li>
<li><strong>示例跳转代码</strong>：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*pFunction)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">uint32_t</span> ApplicationAddress = <span class="number">0x8003000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  跳转到用户程序执行</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Jump_To_User_Program</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	__disable_irq();</span><br><span class="line">    <span class="keyword">if</span> (((*(__IO <span class="type">uint32_t</span> *)ApplicationAddress) &amp; <span class="number">0x2FFE0000</span>) == <span class="number">0x20000000</span>)<span class="comment">//判断用户是否已经下载程序，防止跑飞</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//跳转至用户代码</span></span><br><span class="line">        JumpAddress = *(__IO <span class="type">uint32_t</span> *)(ApplicationAddress + <span class="number">4</span>);</span><br><span class="line">        Jump_To_Application = (pFunction)JumpAddress;</span><br><span class="line">        <span class="comment">//初始化用户程序的堆栈指针</span></span><br><span class="line">        __set_MSP(*(__IO <span class="type">uint32_t</span> *)ApplicationAddress);</span><br><span class="line">        Jump_To_Application();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="五、附录：关键段说明"><a href="#五、附录：关键段说明" class="headerlink" title="五、附录：关键段说明"></a>五、附录：关键段说明</h3><table>
<thead>
<tr>
<th>段名</th>
<th>作用</th>
<th>存储位置</th>
</tr>
</thead>
<tbody><tr>
<td><code>.data</code></td>
<td>存储已初始化的全局变量</td>
<td>RAM</td>
</tr>
<tr>
<td><code>.bss</code></td>
<td>存储未初始化的全局变量（启动时清零）</td>
<td>RAM</td>
</tr>
<tr>
<td><code>.text</code></td>
<td>存储程序代码和常量</td>
<td>Flash</td>
</tr>
<tr>
<td><code>__main</code></td>
<td>C库初始化（堆栈、静态变量等）</td>
<td>自动调用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>IAP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Ymodem+BootLoader进行固件升级</title>
    <url>/archives/d959a1df.html</url>
    <content><![CDATA[<p><em><strong>注1：</strong></em></p>
<p><em><strong>上位机发送的固件后缀必须为<code>.bin</code>而不能为<code>.hex</code>！！！ 具体二者区别可自行搜索……</strong></em></p>
<p><em><strong>注2：</strong></em></p>
<p><em><strong>旧版本的<code>SecureCRT</code>可能会导致传输时首包数据丢失文件大小信息（文件名后边的那个），可用Xshell等其他支持Ymodem协议的工具</strong></em></p>
<h2 id="ISP-amp-IAP-amp-ICP"><a href="#ISP-amp-IAP-amp-ICP" class="headerlink" title="ISP&amp;IAP&amp;ICP"></a>ISP&amp;IAP&amp;ICP</h2><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>ISP即在系统编程<code>（In System Programming）</code>；</p>
<p>该操作是<code>MCU</code>厂商在芯片出厂前已经固化好的<code>BootLoader</code>实现的，该<code>BootLoader</code>存放于flash中的信息块，用户不可操作。</p>
<h3 id="IAP"><a href="#IAP" class="headerlink" title="IAP"></a>IAP</h3><p><code>IAP</code>即在应用编程<code>（In Application Programming）</code>;</p>
<p>该操作需工程师自行编写<code>BootLoader</code>来实现：将芯片Flash区域分割成多个部分，<code>BootLoader</code>存放在Flash开头（大小<code>10kb</code>以内，一般来说，越复杂的功能占用空间越多），其余空间为用户代码区（以下简称<code>APP区</code>）。</p>
<p>如：<code>Flash</code>共<code>64KB</code>，<code>BootLoader</code>占<code>10KB</code>，那么用户代码应存放在<code>Flash</code>的<code>0X08003000</code>地址</p>
<p>该<code>BootLoader</code>要实现的功能一般有：</p>
<ul>
<li>接收上位机发过来的<code>.bin</code>固件并写入<code>APP区</code>（主<code>Flash</code>空间 - <code>BootLoader</code>所占用空间 = <code>APP区</code>）</li>
<li>读取<code>APP区</code>内容并发送给上位机</li>
<li>擦除芯片</li>
</ul>
<p>需要注意的是，如果使用IAP的话，就不可以使用厂家固化好的<code>BootLoader</code>（一般来说是将<code>BOOT0</code>引脚拉低），而应该使用用户自己的<code>BootLoader</code>。</p>
<p>使用用户自己的<code>BootLoader</code>烧录完程序后需执行跳转指令，跳转到<code>APP区</code>，这样就实现了<code>IAP</code>。</p>
<h3 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h3><p><code>ICP</code>即在电路编程<code>（In Circuit Programming）</code>；</p>
<p>使用厂家配套的软件或仿真器进行程序烧录。</p>
<h2 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a>BootLoader</h2><p>以下两张图应该可以很好地反映出<code>BootLoader</code>的作用：</p>
<p><img src="https://s2.loli.net/2025/03/22/XUtmar4wuVDFxlC.png" alt="BOOTLOADER.png"></p>
<img src="https://s2.loli.net/2025/03/24/1UIQMFrKs5t8h6B.png" alt="BootLoader整体流程设计.png" style="zoom:67%;" />


<h2 id="Ymodem"><a href="#Ymodem" class="headerlink" title="Ymodem"></a>Ymodem</h2><p><code>YModem</code>议由<code>XModem</code>协议演变而来，是一种比较高效的文件传输协议，每包数据1024或者128字节。</p>
<h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p><code>Ymodem</code>协议有两种帧格式，主要区别是信息块长度不一样。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>帧头</th>
<th>包号</th>
<th>包号反码</th>
<th>信息块</th>
<th>校验</th>
</tr>
</thead>
<tbody><tr>
<td>简写</td>
<td>SOH/STX</td>
<td>PN</td>
<td>XPN</td>
<td>DATA</td>
<td>CRC16</td>
</tr>
<tr>
<td>字节数</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>128/1024</td>
<td>2</td>
</tr>
</tbody></table>
<h4 id="帧头"><a href="#帧头" class="headerlink" title="帧头"></a>帧头</h4><p>主要用来区分信息块长度；</p>
<p>帧头为<code>SOH</code>（在传输中以<code>0X01</code>表示），表示该帧信息块是128字节；</p>
<p>帧头为<code>STX</code>（在传输中以<code>0X02</code>表示），表示该帧信息块是1024字节。</p>
<h4 id="包序号"><a href="#包序号" class="headerlink" title="包序号"></a>包序号</h4><p>数据包序号只有1字节，因此计算范围是0~255；对于数据包大于255的，序号归零重复计算。</p>
<h4 id="帧长度"><a href="#帧长度" class="headerlink" title="帧长度"></a>帧长度</h4><ol>
<li><p>以<code>SOH(0x01)</code>开始的数据包，<strong>信息块</strong>是128字节，该类型帧总长度为133字节。</p>
</li>
<li><p>以<code>STX(0x02)</code>开始的数据包，<strong>信息块</strong>是1024字节，该类型帧总长度为1029字节  </p>
</li>
</ol>
<h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4><p><code>Ymodem</code>协议采用的是<code>CRC16</code>校验算法，校验值为2字节，传输时<code>CRC</code>高八位在前，低八位在后；<code>CRC</code>计算数据为信息块数据，不包含帧头、包号、包号反码。</p>
<h3 id="握手信号"><a href="#握手信号" class="headerlink" title="握手信号"></a>握手信号</h3><p>握手信号由接收方发起，在发送方开始传输文件前，接收方需发送<code>YMODEM_C</code>字符C <code>即：&#39;C&#39;</code>，<code>ASII</code>码为<code>0x43</code>，发送方收到后，开始传输起始帧。</p>
<h3 id="起始帧"><a href="#起始帧" class="headerlink" title="起始帧"></a>起始帧</h3><p><code>Ymodem</code>起始帧并不直接传输文件内容，而是先将文件名和文件大小置于数据帧中传输；起始帧是以<code>SOH</code> 133字节长度帧传输的，格式如下表：</p>
<table>
<thead>
<tr>
<th>帧头</th>
<th>包号</th>
<th>包号反码</th>
<th>文件名</th>
<th>文件大小</th>
<th>填充区</th>
<th>校验高位</th>
<th>校验低位</th>
</tr>
</thead>
<tbody><tr>
<td>SOH</td>
<td>0X00</td>
<td>0XFF</td>
<td>File Name + 0X00</td>
<td>File Size + 0X00</td>
<td>0X00</td>
<td>CRC-H</td>
<td>CRC-L</td>
</tr>
</tbody></table>
<p>其中包号为固定为0X00；</p>
<p>File Name为文件名称，文件名称后必须加<code>0x00</code>作为结束；</p>
<p>File Size为文件大小值，文件大小值后必须加<code>0x00</code>作为结束；</p>
<p>余下未满128字节数据区域，以<code>0x00</code>填充。</p>
<h3 id="数据帧"><a href="#数据帧" class="headerlink" title="数据帧"></a>数据帧</h3><table>
<thead>
<tr>
<th>帧头</th>
<th>包号</th>
<th>包号反码</th>
<th>有效数据</th>
<th>校验高位</th>
<th>校验低位</th>
</tr>
</thead>
<tbody><tr>
<td>SOH/STX</td>
<td>PN</td>
<td>XPN</td>
<td>DATA</td>
<td>CRC-H</td>
<td>CRC-L</td>
</tr>
</tbody></table>
<p>传输有效数据时，主要考虑的是最后一包数据的处理，<code>SOH</code>帧和<code>STX</code>帧有不同的处理，具体如下：</p>
<ol>
<li>对于<code>SOH</code>帧，若余下数据小于128字节，则以<code>0x1A</code>填充，该帧长度仍为133字节。</li>
<li>对于<code>STX</code>帧需考虑几种情况：<ol>
<li>余下数据等于1024字节，以1029长度帧发送；</li>
<li>余下数据小于1024字节，但大于128字节，以1029字节帧长度发送，无效数据以<code>0x1A</code>填充；</li>
<li>余下数据等于128字节，以133字节帧长度发送；</li>
<li>余下数据小于128字节，以133字节帧长度发送，无效数据以<code>0x1A</code>填充。</li>
</ol>
</li>
</ol>
<h3 id="结束帧"><a href="#结束帧" class="headerlink" title="结束帧"></a>结束帧</h3><p><code>Ymodem</code>协议的结束帧采用<code>SOH</code> 133字节长度帧传输，该帧不携带数据（空包），即数据区、校验都以<code>0x00</code>填充。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>命令码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SOH</td>
<td>0X01</td>
<td>128字节数据包</td>
</tr>
<tr>
<td>STX</td>
<td>0X02</td>
<td>1024字节数据包</td>
</tr>
<tr>
<td>EOT</td>
<td>0X04</td>
<td>结束传输</td>
</tr>
<tr>
<td>ACK</td>
<td>0X06</td>
<td>应答</td>
</tr>
<tr>
<td>NAK</td>
<td>0X15</td>
<td>无应答，需重传当前数据包</td>
</tr>
<tr>
<td>CA</td>
<td>0X18</td>
<td>取消传输，连续两个表示取消</td>
</tr>
<tr>
<td>C</td>
<td>0X43</td>
<td>‘C’ 握手信号</td>
</tr>
<tr>
<td>ABORT1</td>
<td>0X41</td>
<td>‘A’ 用户取消</td>
</tr>
<tr>
<td>ABORT2</td>
<td>0X61</td>
<td>‘a’ 用户取消</td>
</tr>
</tbody></table>
<h3 id="Ymodem完整传输过程"><a href="#Ymodem完整传输过程" class="headerlink" title="Ymodem完整传输过程"></a>Ymodem完整传输过程</h3><blockquote>
<p>SENDER：发送方（文件名：fileName.bin - 12<code>Bytes</code>）<br>RECEIVER：接收方</p>
<p>具体握手的步骤如下：</p>
<ol>
<li>接收方发送一个字符<code>C</code>,也就是十六进制<code>0X43</code>，代表接收方已经处于接收数据的状态。</li>
<li>发送方接收到字符<code>C</code>之后，发送头帧数据包，内容如下：<br> <code>SOH 00 FF fileName.bin fileSize NULL[116] CRC-H CRC-L</code><br> 数据包内容解释：<br> SOH（第1字节）：表示本数据区大小有128字节。（STX表示本数据包数据区大小1024字节）。<br> 00（第2字节）：数据块编号。 <strong>第一包为00，第二包为01，此后依次累加。FF后，继续从00循环。</strong><br> FF（第3字节）：数据块编号的反码。 <strong>编号00-&gt;FF，01-&gt;FE，此后依次类推。</strong><br> fileName.bin <code>NULL[116 - 文件大小所占字节数]</code>：<strong>信息块</strong>128字节。 fileName.bin是文件名，在文件名后面还有文件大小。<strong>数据区不足128字节的，用0x00补齐。</strong><br> <code>CRC</code>校验（最后2个字节）：16位<code>CRC</code>校验，高位字节在前，地位字节在后。（注意：只有数据区进行<code>CRC</code>校验，不包含头、编码、编码反码）。</li>
<li>接收方收到数据包后，发送<code>ACK</code>正确应答，然后发送一个字符<code>C</code>。</li>
<li>发送方收到字符<code>C</code>后，开始发送第二帧数据，<strong>第二帧数据存放的是第一包数据</strong>。</li>
<li>接收方收到数据包后，发送<code>ACK</code>正确应答，然后等待下一包数据传送完毕，继续<code>ACK</code>应答，如此循环。</li>
<li>数据传输完毕后，发送方第一次发<code>EOT</code>，第一次接收方以<code>NAK</code>应答，进行二次确认。</li>
<li>发送方收到<code>NAK</code>后，第二次发<code>EOT</code>。接收方第二次收到结束符，依次以<code>ACK</code>和<code>C</code>作为应答。</li>
<li>发送方收到<code>ACK</code>和<code>C</code>之后，发送结束帧：<code>SOH 00 FF 00...00[128个00] CRC-H CRC-L</code></li>
<li>接收方收到结束符之后，以<code>ACK</code>做应答，然后通信正式结束。</li>
</ol>
<p><em>— 摘自 <a href="https://blog.csdn.net/lbaihao/article/details/124024242">CSDN - STM32基于YModem协议串口升级程序的实现</a></em></p>
</blockquote>
<h3 id="YMODE整体分类总结"><a href="#YMODE整体分类总结" class="headerlink" title="YMODE整体分类总结"></a>YMODE整体分类总结</h3><p><code>YModem</code>分为<code>YModem-1K</code>与<code>YModem-g</code>： </p>
<ul>
<li><p><code>YModem-1K</code>用1024字节信息块传输取代标准的128字节传输，数据的发送回使用<code>CRC</code>校验，保证数据传输的正确性。它每传输一个信息块数据时，就会等待接收端回应<code>ACK</code>信号，接收到回应后，才会继续传输下一个信息块，保证数据已经全部接收。 </p>
</li>
<li><p><code>YModem-g</code>传输形式与<code>YModem-1K</code>差不多，但是它去掉了数据的<code>CRC</code>校验码，同时在发送完一个数据块信息后，它不会等待接收端的<code>ACK</code>信号，而直接传输下一个数据块。正是它没有涉及错误校验，才使得它的传输速度比<code>YModem-1K</code>来得块。 一般都会选择<code>YModem-1K</code>传输，平时所说的<code>YModem</code>也是指的是<code>YModem-1K</code>。</p>
</li>
</ul>
<p><em>— 摘自 <a href="https://blog.csdn.net/luoqjcandy/article/details/134932798">CSDN - YMODE协议注意事项详解</a></em></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>具体代码实现可参考如下链接：</p>
<ul>
<li><a href="https://github.com/Gooost/STM32-IAP/tree/master">Github - STM32-IAP Demo</a></li>
<li><a href="https://github.com/RdMaxes/stm32f4_SerialPort_bootloader/tree/master">Github - STM32F4_SerialPort_BootLoader Demo</a></li>
<li><a href="https://github.com/caoliuchao/STM32F103-UartIAP/tree/master">Github - STM32F103-UartIAP Demo</a></li>
</ul>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/luoqjcandy/article/details/134932798">CSDN - YMODE协议注意事项详解</a></p>
<p><a href="https://blog.csdn.net/lbaihao/article/details/124024242">CSDN - STM32基于YModem协议串口升级程序的实现</a></p>
<p><a href="https://github.com/caoliuchao/STM32F103-UartIAP/tree/master">Github - STM32F103-UartIAP Demo</a></p>
<p><a href="https://github.com/RdMaxes/stm32f4_SerialPort_bootloader/tree/master">Github - STM32F4_SerialPort_BootLoader Demo</a></p>
<p><a href="https://github.com/Gooost/STM32-IAP/tree/master">Github - STM32-IAP Demo</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>Ymodem</category>
        <category>BootLoader</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>Ymodem</tag>
        <tag>BootLoader</tag>
        <tag>IAP</tag>
        <tag>OTA</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式之串口单线通信</title>
    <url>/archives/16a66ba.html</url>
    <content><![CDATA[<h1 id="串口单线通信"><a href="#串口单线通信" class="headerlink" title="串口单线通信"></a>串口单线通信</h1><h3 id="中心思想："><a href="#中心思想：" class="headerlink" title="中心思想："></a>中心思想：</h3><p>主机发送指令，从机收到并正确解析后进行回复，如此循环。</p>
<h3 id="正常情况："><a href="#正常情况：" class="headerlink" title="正常情况："></a>正常情况：</h3><p>主机默认发送，从机默认接收。</p>
<p>主机发送前将串口改为发送模式，发送完毕后恢复为接收模式；</p>
<p>从机收到主机指令并正确解析后将串口改为发送模式，发送完毕后恢复为接收模式。</p>
<h3 id="出错表现："><a href="#出错表现：" class="headerlink" title="出错表现："></a>出错表现：</h3><p>主、从机可以通信且每帧指令包含数据个数相同，但会有数据解析位不符/数据不对位/出现指令外的数据/个别数据连续出错，其之后的数据正常等问题</p>
<h3 id="问题排查："><a href="#问题排查：" class="headerlink" title="问题排查："></a>问题排查：</h3><p>将主、从机之间发送指令改为互发简单重复的数据，如：主机发 <code> n (n &gt; 0)</code> 个 <code>0X01</code> ，观察从机接收数据情况；然后改为 <code>n (n同上)</code> 个 <code>0X02</code>，再观察从机接收数据情况，多次重复，观察接收端数据规律；观察并判断是乱码还是其他情况（例如，数据发送/接收需反转 – communication data is inverted and output）</p>
<p>如果没有规律那就说明数据传输过程中出错，需仔细检查串口配置（波特率、校验…）、发送接收模式转换（如果是单线通信的话）</p>
<h3 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h3><p>主机与从机在数据未传输完毕时就进行了模式转换，导致数据丢失/出错。</p>
<h3 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h3><p>删掉重复的模式转换代码，在合适的位置（即正常情况标题中提到的）进行模式转换即可。</p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>串口</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>串口</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式之IAR工程改名</title>
    <url>/archives/5110d59b.html</url>
    <content><![CDATA[<h2 id="备份！备份！备份！"><a href="#备份！备份！备份！" class="headerlink" title="备份！备份！备份！"></a>备份！备份！备份！</h2><h2 id="改文件（夹）名："><a href="#改文件（夹）名：" class="headerlink" title="改文件（夹）名："></a>改文件（夹）名：</h2><ol>
<li><strong>改工程文件夹名</strong></li>
<li><strong>删掉 <code>Debug</code> 与 <code>settings</code> 文件夹</strong></li>
<li><strong>更改 <code>.dep</code>、<code>.ewd</code>、<code>.ewp</code>、<code>.ewt</code>、<code>.eww</code> 文件的名称</strong></li>
<li><strong>更改 <code>.eww</code> 文件内名（使用文本编辑器打开）</strong></li>
</ol>
<h2 id="改固件名："><a href="#改固件名：" class="headerlink" title="改固件名："></a>改固件名：</h2><ol>
<li><strong>右键点击工程名，选择 <code>options</code>，然后选择 <code>Output Converter</code> -&gt; <code>Output file</code> （或者取消勾选 <code>override default</code>，hex文件将和工程名字相同，此选项用于让用户指定 <code>.hex</code> 文件名）</strong></li>
<li><strong>右键点击工程名，选择 <code>options</code>，然后选择 <code>Linker</code> -&gt; <code>Output</code> -&gt; <code>Output filename</code></strong></li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>IAR</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>IAR</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式之串口通信</title>
    <url>/archives/b956c276.html</url>
    <content><![CDATA[<h1 id="串口数据溢出"><a href="#串口数据溢出" class="headerlink" title="串口数据溢出"></a>串口数据溢出</h1><h2 id="事起缘由"><a href="#事起缘由" class="headerlink" title="事起缘由"></a>事起缘由</h2><p>串口单线通信，遇到一开串口，程序就“卡死”的情况，分析了原因，故有此文。</p>
<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>程序在不断进串口中断函数，造成其他程序无法正常执行。</p>
<p>如果有串口溢出，可以在串口接收中断位置打断点，很容易触发该现象。</p>
<h2 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h2><h3 id="硬件与配置"><a href="#硬件与配置" class="headerlink" title="硬件与配置"></a>硬件与配置</h3><p>出现该现象时先是分析了硬件原因与配置原因：</p>
<ol>
<li>是否波特率相同</li>
</ol>
<ul>
<li>115200波特率的由来：</li>
</ul>
<p>最初是由 11.0592MHz 的晶振 通过6分频， 然后在16分频后，得到的。</p>
<ul>
<li>115200波特率每秒可传输多少个字节？</li>
</ul>
<p>如果设置波特率为115200，设置通信帧为1bit起始位+8bit数据帧+无校验+1bit停止位（传输1个char 需要10bit），那么每秒钟最多可以传输115200bit/10bit = 11520个字节（1个字节大约86.8us；实际使用时由于存在干扰及其他原因，可能要打个8折）。</p>
<ol start="2">
<li>是否频率相同</li>
</ol>
<ul>
<li>两边设置的波特率都为115200，但是波特率是怎么计算呢？</li>
</ul>
<p>在计算前需先明白什么是过采样：以GD32F330R8为例，串口接收器支持x16（默认）过采样和x8过采样，x16过采样即发送方发送数据后，串口接受器会将每个bit采样16次（对一个信号进行16分频采样， 即将信号分成16等分后进行采样，一般取中间的采样值），如果是x8过采样，则采用8次。</p>
<p><img src="https://s2.loli.net/2025/01/10/S2wQWCeuNMZTlFJ.png" alt="串口过采样图示"></p>
<p>baud= uclk / usartdiv 即： 波特率 = 所选串口所在时钟总线的频率 / 波特率分频系数</p>
<p>baud：常见有 9600、19200、115200</p>
<p>uclk：根据不同芯片、不同主频、不同总线来选择，不过常配置为36MHz、54MHz、72MHz</p>
<p>usartdiv：不同过采样率计算方式不同；一般来讲：</p>
<p>x16过采样率计算方式为：usartdiv = uclk / (16 * baud) ；大多芯片默认为x16采样，也可自己配置，寄存器 USART_CTL0中的OVSMOD位，OVSMOD = 0 为x16，OVSMOD = 1 为x8</p>
<p>x8过采样率计算方式为：usartdiv = uclk / (8 * baud)</p>
<ul>
<li>时钟误差</li>
</ul>
<p>采样数据的误差：在最后一个Bit位采样时，允许极限偏移为50%，假如用1个起始位+9个数据位+1个奇偶；校验位+1个停止位来计算，那么每位偏差最高为：±50% / 12 = ±4.16%</p>
<p>因此，对于串口通信来说，可以粗略认为，当时钟误差小于±2%时，通信是比较可靠的。</p>
<p>对于客户实际的应用系统，考虑到UART是一个异步通讯，通讯的稳定性取决于双方的时钟精度，不是说只有一方的精度满足要求，系统就能正常工作，所以需要全局考虑。</p>
<h3 id="软件逻辑"><a href="#软件逻辑" class="headerlink" title="软件逻辑"></a>软件逻辑</h3><p>将所有代码逐步屏蔽，最后定位到串口上。</p>
<p>网上查资料，查芯片用户手册，逐步定位到串口溢出（又称过载 - Overrun）上。以GD32F330为例，串口的溢出标志位（ORERR）位于USART_STAT寄存器中</p>
<p>以下是本次经验与教训：</p>
<p>串口溢出发生一般可能有以下几种情况：</p>
<ul>
<li><p>数据在接收缓冲区中未被及时读取。</p>
</li>
<li><p>串口接收中断被更高优先级的中断打断，且打断时间比较长。</p>
</li>
<li><p>擦写单片机内部flash时，耗时较长，导致串口中断无法响应。</p>
</li>
</ul>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li><p>提高中断优先级。</p>
</li>
<li><p>判断并清除溢出中断标志（ORERR） - 只需读取一下串口数据寄存器（USART_RDATA）即可。</p>
</li>
<li><p>关闭溢出检测功能（不推荐，此操作虽然可以解决”卡死”现象，但可能会使上个数据被覆盖，导致数据丢失）。</p>
</li>
</ul>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><ol>
<li><p>中断程序（不仅仅是串口中断）要响应所有中断，不要只响应接收中断，其他错误中断也要处理，否则会频繁进入中断造成“卡死”。 2 STM32串口只有一个硬件BUF，个人认为是硬伤。115200波特率的情况下，大家算下一个字节是多少us？ 只要串口中断被卡主住这么长时间不处理，就造成溢出。 3 把中断优先级提高、用DMA、人工优化。</p>
</li>
<li><p>尽量及时读取串口接收寄存器中的数据</p>
</li>
</ol>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="RC振荡器"><a href="#RC振荡器" class="headerlink" title="RC振荡器"></a>RC振荡器</h3><p><strong>RC振荡器中的“RC”代表电阻（Resistor）和电容（Capacitor）</strong>‌。</p>
<p>RC振荡器是一种利用电阻和电容元件构成的振荡器，通过这些元件的组合来产生振荡信号。</p>
<h3 id="RC振荡器的基本工作原理"><a href="#RC振荡器的基本工作原理" class="headerlink" title="RC振荡器的基本工作原理"></a>RC振荡器的基本工作原理</h3><p>RC振荡器的工作原理基于RC网络提供的相移。RC网络在电路中产生相位差，通常需要至少两个单极RC网络来获得180度的相移，从而产生振荡。在实际应用中，由于每个RC级很难精确获得90度的相移，因此通常使用多个RC级级联来达到所需的相移。通过调整电阻和电容的值，可以在特定频率下实现稳定的振荡‌。</p>
<h3 id="RC振荡器的类型和应用"><a href="#RC振荡器的类型和应用" class="headerlink" title="RC振荡器的类型和应用"></a>RC振荡器的类型和应用</h3><p>RC振荡器有多种类型，包括桥式振荡电路和双T式振荡电路等。桥式振荡电路是最常用的类型之一，它利用RC串并联选频网络来实现振荡。这些不同类型的RC振荡器在电子设备中有广泛的应用，例如在无线电、通信系统、时钟电路等中‌。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/lljss1980/article/details/127115652">CSDN - GD32串口一直进溢出中断</a></p>
<p><a href="https://blog.csdn.net/weixin_46801290/article/details/124526979">CSDN - 串口通信USART的波特率误差计算</a></p>
<p><a href="https://blog.csdn.net/flighting_/article/details/143492233">CSDN - 串口通讯与时钟误差的影响</a></p>
<p><a href="https://blog.csdn.net/liuxd3000/article/details/128396918">CSDN - 串口通讯到底有没有累积误差？对时钟精度到底有何要求？</a></p>
<p><a href="https://blog.csdn.net/qq_62316532/article/details/139765518">CSDN - 串口通讯乱码</a></p>
<p><a href="https://m.elecfans.com/article/2057395.html">电子发烧友 - 波特率误差产生原因</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>串口</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>串口</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式之ADC</title>
    <url>/archives/c8ae9f13.html</url>
    <content><![CDATA[<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><p>ADC - 模数转换器：<br>以GD32DF330为例，MCU片上集成了12位逐次逼近式模数转换器模块（ADC），可以采样来自于16个外部通道、2个内部通道和电池电压（VBAT）通道的模拟信号。</p>
<h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p>假如ADC采样分辨率为12位，输入信号最大值为3.3V，那么这个转换器应能区分出输入信号的最小电压为 3.3 / (2 ^ 12) = 0.806mV</p>
<h2 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h2><p>转换时间是指模数转换器从模拟信号到来开始，到输出端得到稳定的数字信号所经过的时间。<br>假如ADC采样分辨率为12位，那么：<br>总转换时间 = 采样时间 + 12.5个CK_ADC周期<br><img src="https://s2.loli.net/2024/12/06/UfXOHoaKDsLnSRq.png" alt="转换时间"></p>
<p>通道采样时间由 ADC_SAMPTn 寄存器配置，共有8种选择（从 1.5采样周期 到 239.5采样周期）。<br>例如： CK_ADC为6MHz ，采样时间配置为55.5个采样周期，那么总的转换时间为：”55.5 + 12.5”个 CK_ADC 周期，即(1 / 6000000) * (55.5 + 12.5) = 0.0113us = 11.3ns。</p>
<h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><h3 id="单次转换，非扫描模式："><a href="#单次转换，非扫描模式：" class="headerlink" title="单次转换，非扫描模式："></a>单次转换，非扫描模式：</h3><p>在第一次ADC触发之后，将AD值存在数据寄存器里面，并且会将EOC(End Of Conversion - 转换结束)标志位置1，根据这个标志位判断转换状态状态，如果转换完毕，就读取数据。<br>在读取数据寄存器之后，硬件会自动将EOC标志位清零，那么就可以开始下一次转换了。</p>
<h3 id="连续转换，非扫描模式："><a href="#连续转换，非扫描模式：" class="headerlink" title="连续转换，非扫描模式："></a>连续转换，非扫描模式：</h3><p>这个模式开启转换之后不需要判断标志位，一次转换结束之后会继续开启下一次转换，直到失能ADC；<br>所以配置完ADC后，只需要开启一次转换即可，然后需要AD值的数据的时候直接去寄存器读取即可。</p>
<h3 id="单次转换，扫描模式："><a href="#单次转换，扫描模式：" class="headerlink" title="单次转换，扫描模式："></a>单次转换，扫描模式：</h3><p>在这个模式中，可以一次转换多个通道，一次将多个通道转换的数据存入数据寄存器，然后在转换结束的时候产生一个EOC标志位，读取数据寄存器后硬件会自动清除EOC的标志位，等待开启下一次的转换。<br>需要注意的是，需要进行通道数目的配置（只在扫描模式的时候配置），一次扫描多个通道，进行AD转换。<br>假如通道数目配置为7，则只看前7个序列所对应的通道。</p>
<h3 id="连续转换，扫描模式："><a href="#连续转换，扫描模式：" class="headerlink" title="连续转换，扫描模式："></a>连续转换，扫描模式：</h3><p>这个模式，只需开启一次转换，转换结束会自动进行下一次转换。<br>但是规则组的数据寄存器只有16位，所以只能存入1个通道的数据，如果不及时转存数据的话，本次的数据会被下一个通道的数据覆盖。</p>
<h3 id="间断模式"><a href="#间断模式" class="headerlink" title="间断模式"></a>间断模式</h3><p>ADC扫描被规则通道和注入通道选中的所有通道，在每个组的每个通道上执行单次转换。</p>
<p>在每个转换结束时，这一组的下一个通道被自动转换。如果开启了连续转换模式，转换不会在选择组的最后一个通道上停止，而是再次从选择组的第一个通道继续转换。触发一次，转换一个通道，再触发，再转换。在所选转换通道循环，由触发信号启动新一轮的转换，直到转换完成为止。</p>
<p>扫描模式简单的说是一次对所有所选中的通道进行转换，比如开了CH0，CH1，CH4，CH5。CH0转换完以后就会自动转换通道1，4，5直到转换完，这个过程不能被打断。如果开启了连续转换模式，则会在转换完CH5之后开始新一轮的转换。</p>
<p>这就引入了间断模式，可以说是对扫描模式的一种补充。它可以把CH0，CH1，CH4，CH5这四个通道进行分组。可以分成0、1一组，4、5一组。也可以每个通道单独配置为一组；这样每一组转换之前都需要先触发一次。</p>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><h3 id="规则通道"><a href="#规则通道" class="headerlink" title="规则通道"></a>规则通道</h3><p>规则组可以设置由1个或多个ADC通道组成的转换序列，当启动转换时，ADC将按照转换序列中指定的ADC通道顺序和序列长度进行转换<br>一个规则转换组最多由16个转换构成， 规则通道的转换结果储存在常规数据寄存器”ADC_RDATA”中；<strong>所有规则通道的转换结果均共用此规则数据寄存器</strong>，因此为避免数据丢失，在每个通道转换完毕时应尽快将转换结果读出，如果转换足够快则应使用DMA。</p>
<h3 id="注入通道"><a href="#注入通道" class="headerlink" title="注入通道"></a>注入通道</h3><p>如果将规则通道比作普通C函数，则注入通道就像是中断服务函数一样。<br>注入通道可以中断规则通道的转换，然后在注入通道组转换完成后，规则通道组的规则转换会从上次中断的规则转换处恢复。<br>注入组可以设置由1个或多个ADC通道组成的转换序列，当启动转换时，ADC将按照转换序列中指定的ADC通道顺序和序列长度进行转换。<br>一个注入转换组最多由4个转换构成， 注入通道的转换结果储存在注入数据寄存器”ADC_IDATAn (n为0~3)”中。它们包括来自注入通道 n 的转换结果。</p>
<h2 id="触发方式（转换开始的发起）"><a href="#触发方式（转换开始的发起）" class="headerlink" title="触发方式（转换开始的发起）"></a>触发方式（转换开始的发起）</h2><ul>
<li>软件触发</li>
<li>硬件触发</li>
</ul>
<p><img src="https://s2.loli.net/2024/12/06/JsBknwVK1SyZ6g4.png" alt="触发方式"><br>常用软件触发</p>
<h2 id="中断的产生："><a href="#中断的产生：" class="headerlink" title="中断的产生："></a>中断的产生：</h2><ul>
<li>常规序列转换结束</li>
<li>模拟看门狗事件</li>
</ul>
<p>常用 “单次转换 + 常规序列转换结束中断” 来采样</p>
]]></content>
      <categories>
        <category>ADC</category>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>ADC</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式之队列</title>
    <url>/archives/c146dddc.html</url>
    <content><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p><strong>顺序队列存在假溢出的现象：</strong><br>假溢出‌是指在使用顺序存储队列时，队列作为存储区还没有满，但由于队列的操作规则（队首删除、队尾插入），导致队尾指针已经占满了所有空间，而队首仍有空闲单元的现象。</p>
<p><strong>假溢出的原因：</strong><br>假溢出的原因在于顺序存储队列的操作规则。<br>队列允许在队首进行删除操作，在队尾进行插入操作。当队尾指针达到数组的最大容量时，如果队首指针不指向数组的起始位置，队列中仍然有空闲单元，但再进行入队操作会导致假溢出。</p>
<p><strong>解决：</strong><br>可采用循环队列</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>将队列看成首尾相连的循环队列，通过牺牲一个单元来判断队列是否满。<br>具体实现可以通过以下方式：<br>‌牺牲一个单元：当队尾指针加一等于队首指针时，判断为队列满，即 (tail + 1) % QUEUE_SIZE == head</p>
<p><strong>注意：</strong></p>
<ol>
<li>使用循环队列时，其队列长度一般都要比要存入的数据长度大</li>
<li>队列的最后一个元素永远不会被使用，这就是第一点的原因</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_SIZE 50</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">queue</span>[QUEUE_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>; <span class="comment">// 队头出</span></span><br><span class="line"><span class="type">int</span> tail = <span class="number">0</span>; <span class="comment">// 队尾进</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_queue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((tail + <span class="number">1</span>) % QUEUE_SIZE == head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;QUEUE IS FULL!\n&quot;</span>); <span class="comment">// 队满</span></span><br><span class="line">        init_queue(); <span class="comment">// 队头、队尾清零；重新开始，即循环队列</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>[tail] = value;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % QUEUE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;QUEUE IS EMPTY!\n&quot;</span>); <span class="comment">// 队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">queue</span>[head];</span><br><span class="line">    <span class="built_in">queue</span>[head] = <span class="number">0</span>;</span><br><span class="line">    head = (head + <span class="number">1</span>) % QUEUE_SIZE;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = head;</span><br><span class="line">    <span class="keyword">while</span> (i != tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">queue</span>[i]);</span><br><span class="line">        i = (i + <span class="number">1</span>) % QUEUE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        enqueue(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printQueue(); <span class="comment">// QUEUE IS FULL!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">49</span>; i &lt; <span class="number">98</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        enqueue(i);</span><br><span class="line">    &#125;</span><br><span class="line">    printQueue(); <span class="comment">// 49 ~ 98</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式之二分法</title>
    <url>/archives/c6964807.html</url>
    <content><![CDATA[<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是一个简单的例子：根据ADC值查找对应温度值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> ADC_Table[<span class="number">101</span>] = &#123;</span><br><span class="line">    <span class="number">3999</span>,</span><br><span class="line">    <span class="number">3967</span>, <span class="number">3961</span>, <span class="number">3954</span>, <span class="number">3947</span>, <span class="number">3940</span>, <span class="number">3932</span>, <span class="number">3924</span>, <span class="number">3916</span>, <span class="number">3907</span>, <span class="number">3899</span>,</span><br><span class="line">    <span class="number">3889</span>, <span class="number">3880</span>, <span class="number">3870</span>, <span class="number">3860</span>, <span class="number">3850</span>, <span class="number">3839</span>, <span class="number">3827</span>, <span class="number">3816</span>, <span class="number">3804</span>, <span class="number">3791</span>,</span><br><span class="line">    <span class="number">3779</span>, <span class="number">3766</span>, <span class="number">3752</span>, <span class="number">3738</span>, <span class="number">3724</span>, <span class="number">3708</span>, <span class="number">3693</span>, <span class="number">3676</span>, <span class="number">3660</span>, <span class="number">3643</span>,</span><br><span class="line">    <span class="number">3625</span>, <span class="number">3607</span>, <span class="number">3589</span>, <span class="number">3570</span>, <span class="number">3550</span>, <span class="number">3530</span>, <span class="number">3510</span>, <span class="number">3489</span>, <span class="number">3468</span>, <span class="number">3446</span>,</span><br><span class="line">    <span class="number">3424</span>, <span class="number">3401</span>, <span class="number">3378</span>, <span class="number">3354</span>, <span class="number">3330</span>, <span class="number">3306</span>, <span class="number">3281</span>, <span class="number">3255</span>, <span class="number">3229</span>, <span class="number">3203</span>,</span><br><span class="line">    <span class="number">3175</span>, <span class="number">3146</span>, <span class="number">3117</span>, <span class="number">3088</span>, <span class="number">3058</span>, <span class="number">3028</span>, <span class="number">2997</span>, <span class="number">2966</span>, <span class="number">2935</span>, <span class="number">2903</span>,</span><br><span class="line">    <span class="number">2871</span>, <span class="number">2839</span>, <span class="number">2806</span>, <span class="number">2774</span>, <span class="number">2741</span>, <span class="number">2707</span>, <span class="number">2674</span>, <span class="number">2640</span>, <span class="number">2607</span>, <span class="number">2573</span>,</span><br><span class="line">    <span class="number">2539</span>, <span class="number">2505</span>, <span class="number">2471</span>, <span class="number">2436</span>, <span class="number">2402</span>, <span class="number">2368</span>, <span class="number">2334</span>, <span class="number">2300</span>, <span class="number">2265</span>, <span class="number">2231</span>,</span><br><span class="line">    <span class="number">2197</span>, <span class="number">2163</span>, <span class="number">2130</span>, <span class="number">2096</span>, <span class="number">2063</span>, <span class="number">2028</span>, <span class="number">1993</span>, <span class="number">1959</span>, <span class="number">1925</span>, <span class="number">1891</span>,</span><br><span class="line">    <span class="number">1857</span>, <span class="number">1823</span>, <span class="number">1790</span>, <span class="number">1758</span>, <span class="number">1725</span>, <span class="number">1693</span>, <span class="number">1661</span>, <span class="number">1630</span>, <span class="number">1599</span>, <span class="number">1580</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief       查询ADC对应温度</span></span><br><span class="line"><span class="comment"> * @param[1]    arr ADC数组</span></span><br><span class="line"><span class="comment"> * @param[2]    left right 数组的首末下标</span></span><br><span class="line"><span class="comment"> * @param[3]    x 实时获取的ADC值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">adc_search</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span>* arr, <span class="type">unsigned</span> <span class="type">char</span> left, <span class="type">unsigned</span> <span class="type">char</span> right, <span class="type">unsigned</span> <span class="type">short</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= arr[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= arr[<span class="number">100</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= x &amp;&amp; arr[mid + <span class="number">1</span>] &lt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">adc_search(ADC_Table, <span class="number">0</span>, <span class="number">100</span>, ntc_adc);</span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>二分法为什么会陷入死循环？</li>
</ol>
<p>判断条件选取的不对，多一个 <code>=</code> 就有可能陷入死循环；另外数组最好为<strong>单数</strong>，双数极可能陷入死循环</p>
<ol start="2">
<li>为什么 <code>while (left &lt;= right)</code> 用 <code>&lt;= </code> 不用  <code>&lt; </code> ？</li>
</ol>
<p>因为 <code>right</code> 的值为 <code>数组元素个数 - 1</code> ，这时 <code>left</code> 与 <code>right</code> 是可以相等的</p>
<ol start="3">
<li>为什么取中间数要写成 <code>int mid = left + (right - left) / 2;</code> 这样？</li>
</ol>
<p>因为若 <code>left + right</code> 很大的时候会发生整形溢出，这样写可以尽量避免</p>
<ol start="4">
<li>为什么判断条件写成 <code>if (arr[mid] &gt;= x &amp;&amp; arr[mid + 1] &lt;= x)</code> 这样？</li>
</ol>
<p>因为数组元素为 <code>unsigned short</code> 型，不会出现浮点数，且数组元素不是等差为1的等差数列，不是非此即彼，可能会出现 <code>arr[mid] &gt;= x &amp;&amp; arr[mid + 1] &lt;= x</code> 这种情况</p>
<ol start="5">
<li>建议：遇到死循环将 <code>left</code> <code>right</code> <code>mid</code> 打印出来看看，以判断死循环原因</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式之ADC数据的处理方法</title>
    <url>/archives/b959f812.html</url>
    <content><![CDATA[<h2 id="ADC数据的处理方法"><a href="#ADC数据的处理方法" class="headerlink" title="ADC数据的处理方法"></a>ADC数据的处理方法</h2><p>为什么要对采样的数据进行处理呢？直接拿来用不行吗？<br>因为任何系统都会存在干扰，进行数据处理就是为了尽量避免因外界干扰引起的误差。</p>
<h3 id="常用的两种滤波方法"><a href="#常用的两种滤波方法" class="headerlink" title="常用的两种滤波方法"></a>常用的两种滤波方法</h3><ol>
<li>多次采样加权取平均，在写程序的时候可以运用一些技巧：首先我们ADC采集8次数据并且对这8次数据累加（可以每1ms调用一次该函数），累加完成后将累加结果右移3位得到最后的采样结果；当然这个方法还可以进一步改善，比如取样10次，然后去掉最大值和最小值，再对剩下的8次进行取平均。</li>
</ol>
<p><strong>但因为需要多次采样，更新数据的时间会很长，比如取样8次，每1ms取样一次，那么更新数据就需要8ms时间，所以对采样的数据实时性要求不是很高的系统才可以用这种方法</strong></p>
<ol start="2">
<li>中值滤波法（可用在实时性比较高的系统）：实现思想就是取5个数据，每次采样的新数据替换掉最老的数据；然后把中间的那个数据当做是采样数据，这样不仅可以有效抑制干扰，而且响应速度快。</li>
</ol>
<h3 id="十大滤波方法及代码实现"><a href="#十大滤波方法及代码实现" class="headerlink" title="十大滤波方法及代码实现"></a>十大滤波方法及代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> table[<span class="number">255</span>] = &#123;</span><br><span class="line">    <span class="number">2048</span>, <span class="number">2098</span>, <span class="number">2148</span>, <span class="number">2198</span>, <span class="number">2248</span>, <span class="number">2298</span>, <span class="number">2348</span>, <span class="number">2398</span>, <span class="number">2447</span>, <span class="number">2496</span>,</span><br><span class="line">    <span class="number">2545</span>, <span class="number">2594</span>, <span class="number">2642</span>, <span class="number">2690</span>, <span class="number">2737</span>, <span class="number">2785</span>, <span class="number">2831</span>, <span class="number">2877</span>, <span class="number">2923</span>, <span class="number">2968</span>,</span><br><span class="line">    <span class="number">3013</span>, <span class="number">3057</span>, <span class="number">3100</span>, <span class="number">3143</span>, <span class="number">3185</span>, <span class="number">3227</span>, <span class="number">3267</span>, <span class="number">3307</span>, <span class="number">3347</span>, <span class="number">3385</span>,</span><br><span class="line">    <span class="number">3423</span>, <span class="number">3460</span>, <span class="number">3496</span>, <span class="number">3531</span>, <span class="number">3565</span>, <span class="number">3598</span>, <span class="number">3631</span>, <span class="number">3662</span>, <span class="number">3692</span>, <span class="number">3722</span>,</span><br><span class="line">    <span class="number">3750</span>, <span class="number">3778</span>, <span class="number">3804</span>, <span class="number">3829</span>, <span class="number">3854</span>, <span class="number">3877</span>, <span class="number">3899</span>, <span class="number">3920</span>, <span class="number">3940</span>, <span class="number">3958</span>,</span><br><span class="line">    <span class="number">3976</span>, <span class="number">3992</span>, <span class="number">4007</span>, <span class="number">4021</span>, <span class="number">4034</span>, <span class="number">4046</span>, <span class="number">4056</span>, <span class="number">4065</span>, <span class="number">4073</span>, <span class="number">4080</span>,</span><br><span class="line">    <span class="number">4086</span>, <span class="number">4090</span>, <span class="number">4093</span>, <span class="number">4095</span>, <span class="number">4095</span>, <span class="number">4095</span>, <span class="number">4093</span>, <span class="number">4090</span>, <span class="number">4086</span>, <span class="number">4080</span>,</span><br><span class="line">    <span class="number">4073</span>, <span class="number">4065</span>, <span class="number">4056</span>, <span class="number">4046</span>, <span class="number">4034</span>, <span class="number">4021</span>, <span class="number">4007</span>, <span class="number">3992</span>, <span class="number">3976</span>, <span class="number">3958</span>,</span><br><span class="line">    <span class="number">3940</span>, <span class="number">3920</span>, <span class="number">3899</span>, <span class="number">3877</span>, <span class="number">3854</span>, <span class="number">3829</span>, <span class="number">3804</span>, <span class="number">3778</span>, <span class="number">3750</span>, <span class="number">3722</span>,</span><br><span class="line">    <span class="number">3692</span>, <span class="number">3662</span>, <span class="number">3631</span>, <span class="number">3598</span>, <span class="number">3565</span>, <span class="number">3531</span>, <span class="number">3496</span>, <span class="number">3460</span>, <span class="number">3423</span>, <span class="number">3385</span>,</span><br><span class="line">    <span class="number">3347</span>, <span class="number">3307</span>, <span class="number">3267</span>, <span class="number">3227</span>, <span class="number">3185</span>, <span class="number">3143</span>, <span class="number">3100</span>, <span class="number">3057</span>, <span class="number">3013</span>, <span class="number">2968</span>,</span><br><span class="line">    <span class="number">2923</span>, <span class="number">2877</span>, <span class="number">2831</span>, <span class="number">2785</span>, <span class="number">2737</span>, <span class="number">2690</span>, <span class="number">2642</span>, <span class="number">2594</span>, <span class="number">2545</span>, <span class="number">2496</span>,</span><br><span class="line">    <span class="number">2447</span>, <span class="number">2398</span>, <span class="number">2348</span>, <span class="number">2298</span>, <span class="number">2248</span>, <span class="number">2198</span>, <span class="number">2148</span>, <span class="number">2098</span>, <span class="number">2047</span>, <span class="number">1997</span>,</span><br><span class="line">    <span class="number">1947</span>, <span class="number">1897</span>, <span class="number">1847</span>, <span class="number">1797</span>, <span class="number">1747</span>, <span class="number">1697</span>, <span class="number">1648</span>, <span class="number">1599</span>, <span class="number">1550</span>, <span class="number">1501</span>,</span><br><span class="line">    <span class="number">1453</span>, <span class="number">1405</span>, <span class="number">1358</span>, <span class="number">1310</span>, <span class="number">1264</span>, <span class="number">1218</span>, <span class="number">1172</span>, <span class="number">1127</span>, <span class="number">1082</span>, <span class="number">1038</span>,</span><br><span class="line">    <span class="number">995</span>, <span class="number">952</span>, <span class="number">910</span>, <span class="number">868</span>, <span class="number">828</span>, <span class="number">788</span>, <span class="number">748</span>, <span class="number">710</span>, <span class="number">672</span>, <span class="number">635</span>,</span><br><span class="line">    <span class="number">599</span>, <span class="number">564</span>, <span class="number">530</span>, <span class="number">497</span>, <span class="number">464</span>, <span class="number">433</span>, <span class="number">403</span>, <span class="number">373</span>, <span class="number">345</span>, <span class="number">317</span>,</span><br><span class="line">    <span class="number">291</span>, <span class="number">266</span>, <span class="number">241</span>, <span class="number">218</span>, <span class="number">196</span>, <span class="number">175</span>, <span class="number">155</span>, <span class="number">137</span>, <span class="number">119</span>, <span class="number">103</span>,</span><br><span class="line">    <span class="number">88</span>, <span class="number">74</span>, <span class="number">61</span>, <span class="number">49</span>, <span class="number">39</span>, <span class="number">30</span>, <span class="number">22</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">5</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">30</span>,</span><br><span class="line">    <span class="number">39</span>, <span class="number">49</span>, <span class="number">61</span>, <span class="number">74</span>, <span class="number">88</span>, <span class="number">103</span>, <span class="number">119</span>, <span class="number">137</span>, <span class="number">155</span>, <span class="number">175</span>,</span><br><span class="line">    <span class="number">196</span>, <span class="number">218</span>, <span class="number">241</span>, <span class="number">266</span>, <span class="number">291</span>, <span class="number">317</span>, <span class="number">345</span>, <span class="number">373</span>, <span class="number">403</span>, <span class="number">433</span>,</span><br><span class="line">    <span class="number">464</span>, <span class="number">497</span>, <span class="number">530</span>, <span class="number">564</span>, <span class="number">599</span>, <span class="number">635</span>, <span class="number">672</span>, <span class="number">710</span>, <span class="number">748</span>, <span class="number">788</span>,</span><br><span class="line">    <span class="number">828</span>, <span class="number">868</span>, <span class="number">910</span>, <span class="number">952</span>, <span class="number">995</span>, <span class="number">1038</span>, <span class="number">1082</span>, <span class="number">1127</span>, <span class="number">1172</span>, <span class="number">1218</span>,</span><br><span class="line">    <span class="number">1264</span>, <span class="number">1310</span>, <span class="number">1358</span>, <span class="number">1405</span>, <span class="number">1453</span>, <span class="number">1501</span>, <span class="number">1550</span>, <span class="number">1599</span>, <span class="number">1648</span>, <span class="number">1697</span>,</span><br><span class="line">    <span class="number">1747</span>, <span class="number">1797</span>, <span class="number">1847</span>, <span class="number">1897</span>, <span class="number">1947</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************</span></span><br><span class="line"><span class="comment">方法一：限幅滤波法</span></span><br><span class="line"><span class="comment">方法：根据经验判断，确定两次采样允许的最大偏差值（设为A），每次检测到新值时判断：</span></span><br><span class="line"><span class="comment">      如果本次值与上次值之差&lt;=A，则本次值有效，</span></span><br><span class="line"><span class="comment">      如果本次值与上次值之差&gt;A，则本次值无效，放弃本次值，用上次值代替本次值。</span></span><br><span class="line"><span class="comment">优点：能克服偶然因素引起的脉冲干扰</span></span><br><span class="line"><span class="comment">缺点：无法抑制周期性的干扰，平滑度差</span></span><br><span class="line"><span class="comment">******************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> A 51</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> Value1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="title function_">filter1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">short</span> NewValue = <span class="number">0</span>;</span><br><span class="line">    Value1                         = table[b - <span class="number">1</span>];</span><br><span class="line">    NewValue                       = table[b];</span><br><span class="line"></span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">254</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b++;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">255</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((NewValue - Value1) &gt; A) || ((Value1 - NewValue) &gt; A))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, NewValue - Value1, NewValue, Value1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************</span></span><br><span class="line"><span class="comment">方法二：中位值滤波法</span></span><br><span class="line"><span class="comment">方法： 连续采样N次（N取奇数），把N次采样值按大小排列，取中间值为本次有效值。</span></span><br><span class="line"><span class="comment">优点：克服偶然因素（对温度、液位的变化缓慢的被测参数有良好的滤波效果）</span></span><br><span class="line"><span class="comment">缺点：对流量、速度等快速变化的参数不宜</span></span><br><span class="line"><span class="comment">******************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> value_buf[N];</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="title function_">filter2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> count, i, j, temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将采集的ADC值分别存入数组中，且后边存的值覆盖前边存的值</span></span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; N; count++)</span><br><span class="line">    &#123;</span><br><span class="line">        value_buf[count] = table[a];</span><br><span class="line">        a++;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">254</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冒泡排序 - 从小到大排</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N - <span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N - <span class="number">1</span> - j; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (value_buf[i] &gt; value_buf[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp             = value_buf[i];</span><br><span class="line">                value_buf[i]     = value_buf[i + <span class="number">1</span>];</span><br><span class="line">                value_buf[i + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选出中位数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, value_buf[(N - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************</span></span><br><span class="line"><span class="comment">方法三：算术平均滤波法</span></span><br><span class="line"><span class="comment">方法：连续取N个采样值进行算术平均运算：（ N值的选取：一般流量，N=12；压力：N=4。）</span></span><br><span class="line"><span class="comment">      N值较大时：信号平滑度较高，但灵敏度较低；</span></span><br><span class="line"><span class="comment">      N值较小时：信号平滑度较低，但灵敏度较高；</span></span><br><span class="line"><span class="comment">优点：适用于对一般具有随机干扰的信号进行滤波；这种信号的特点是有一个平均值，信号在某一数值范围附近上下波动</span></span><br><span class="line"><span class="comment">缺点：对于测量速度较慢或要求数据计算速度较快的实时控制不适用，比较浪费RAM。</span></span><br><span class="line"><span class="comment">******************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="title function_">filter3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sum = <span class="number">0</span>, count;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; N; count++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += table[a];</span><br><span class="line">        a++;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">254</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum / N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************</span></span><br><span class="line"><span class="comment">方法四：递推平均滤波法（又称滑动平均滤波法）</span></span><br><span class="line"><span class="comment">方法： 把连续取得的N个采样值看成一个队列，队列的长度固定为N，</span></span><br><span class="line"><span class="comment">       每次采样到一个新数据放入队尾，并扔掉原来队首的一次数据（先进先出原则），</span></span><br><span class="line"><span class="comment">       把队列中的N个数据进行算术平均运算，获得新的滤波结果。</span></span><br><span class="line"><span class="comment">       N值的选取：流量，N=12；压力，N=4；液面，N=4-12；温度，N=1-4。</span></span><br><span class="line"><span class="comment">优点：对周期性干扰有良好的抑制作用，平滑度高；</span></span><br><span class="line"><span class="comment">      适用于高频振荡的系统。</span></span><br><span class="line"><span class="comment">缺点：灵敏度低，对偶然出现的脉冲性干扰的抑制作用较差；</span></span><br><span class="line"><span class="comment">      不易消除由于脉冲干扰所引起的采样值偏差；</span></span><br><span class="line"><span class="comment">      不适用于脉冲干扰比较严重的场合；</span></span><br><span class="line"><span class="comment">      比较浪费RAM。</span></span><br><span class="line"><span class="comment">******************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILTER4_N 3</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> filter_buf[FILTER4_N + <span class="number">1</span>]; <span class="comment">// 滑动窗口大小 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="title function_">filter4</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>                 i = <span class="number">0</span>, filter_sum = <span class="number">0</span>;</span><br><span class="line">    filter_buf[FILTER4_N] = table[a]; <span class="comment">// 将采集得到的数据依次存放到窗口数组最后</span></span><br><span class="line"></span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">254</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FILTER4_N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// i = 0 1 2</span></span><br><span class="line">        j++;</span><br><span class="line">        filter_buf[i] = filter_buf[i + <span class="number">1</span>]; <span class="comment">// 将窗口数组元素左移，即舍弃窗口数组的0元素</span></span><br><span class="line">        filter_sum += filter_buf[i];       <span class="comment">// 累加窗口数组前三个元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两轮过后才出现正确的均值，一轮3次，两轮6次；故 &gt; 6</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, filter_sum / FILTER4_N); <span class="comment">// 窗口的前三个元素求平均</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************</span></span><br><span class="line"><span class="comment">方法五：中位值平均滤波法（又称防脉冲干扰平均滤波法）</span></span><br><span class="line"><span class="comment">方法： 采一组队列去掉最大值和最小值后取平均值，     （N值的选取：3-14）。</span></span><br><span class="line"><span class="comment">      相当于“中位值滤波法”+“算术平均滤波法”。</span></span><br><span class="line"><span class="comment">      连续采样N个数据，去掉一个最大值和一个最小值，</span></span><br><span class="line"><span class="comment">      然后计算N-2个数据的算术平均值。</span></span><br><span class="line"><span class="comment">优点： 融合了“中位值滤波法”+“算术平均滤波法”两种滤波法的优点。</span></span><br><span class="line"><span class="comment">       对于偶然出现的脉冲性干扰，可消除由其所引起的采样值偏差。</span></span><br><span class="line"><span class="comment">       对周期干扰有良好的抑制作用。</span></span><br><span class="line"><span class="comment">       平滑度高，适于高频振荡的系统。</span></span><br><span class="line"><span class="comment">缺点：对于测量速度较慢或要求数据计算速度较快的实时控制不适用，比较浪费RAM。</span></span><br><span class="line"><span class="comment">******************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 3</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">filter5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> filter_temp, filter_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> filter_buf[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// i = 0 1 2</span></span><br><span class="line">        filter_buf[i] = table[a];</span><br><span class="line">        a++;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">254</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冒泡排序 - 从小到大排</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N - <span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N - <span class="number">1</span> - j; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter_buf[i] &gt; filter_buf[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                filter_temp       = filter_buf[i];</span><br><span class="line">                filter_buf[i]     = filter_buf[i + <span class="number">1</span>];</span><br><span class="line">                filter_buf[i + <span class="number">1</span>] = filter_temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除最大最小极值后求平均 - filter_buf[0]为最小值，filter_buf[N]为最大值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// i = 1</span></span><br><span class="line">        filter_sum += filter_buf[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, filter_sum / (N - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************</span></span><br><span class="line"><span class="comment">方法六：限幅平均滤波法</span></span><br><span class="line"><span class="comment">方法： 相当于“限幅滤波法”+“递推平均滤波法”；</span></span><br><span class="line"><span class="comment">       每次采样到的新数据先进行限幅处理，</span></span><br><span class="line"><span class="comment">       再送入队列进行递推平均滤波处理。</span></span><br><span class="line"><span class="comment">优点： 融合了两种滤波法的优点；</span></span><br><span class="line"><span class="comment">      对于偶然出现的脉冲性干扰，可消除由于脉冲干扰所引起的采样值偏差。</span></span><br><span class="line"><span class="comment">缺点：比较浪费RAM。</span></span><br><span class="line"><span class="comment">******************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILTER6_N 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILTER6_A 51</span></span><br><span class="line"><span class="type">int</span> filter_buf[FILTER6_N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">filter6</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> filter_sum            = <span class="number">0</span>;</span><br><span class="line">    filter_buf[FILTER6_N - <span class="number">1</span>] = table[a]; <span class="comment">// 将采样值依次存到数组最后一个元素</span></span><br><span class="line"></span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">254</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        filter_buf[FILTER6_N - <span class="number">3</span>] = table[<span class="number">0</span>];</span><br><span class="line">        filter_buf[FILTER6_N - <span class="number">2</span>] = table[<span class="number">1</span>];</span><br><span class="line">        filter_buf[FILTER6_N - <span class="number">1</span>] = table[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 若 filter_buf数组 中后两个元素之差大于 FILTER6_A</span></span><br><span class="line">        <span class="keyword">if</span> (((filter_buf[FILTER6_N - <span class="number">1</span>] - filter_buf[FILTER6_N - <span class="number">2</span>]) &gt; FILTER6_A) || ((filter_buf[FILTER6_N - <span class="number">2</span>] - filter_buf[FILTER6_N - <span class="number">1</span>]) &gt; FILTER6_A))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将倒数第二个元素覆盖最后一个元素 - 若超出规定幅值，则舍弃本次采集的值，并使用上次的ADC值代替</span></span><br><span class="line">            filter_buf[FILTER6_N - <span class="number">1</span>] = filter_buf[FILTER6_N - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FILTER6_N - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// i = 0 1</span></span><br><span class="line">            filter_buf[i] = filter_buf[i + <span class="number">1</span>]; <span class="comment">// 数组元素左移</span></span><br><span class="line">            filter_sum += filter_buf[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, filter_sum / (FILTER6_N - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************</span></span><br><span class="line"><span class="comment">方法七：一阶滞后滤波法</span></span><br><span class="line"><span class="comment">方法： 取a=0-1，本次滤波结果=(1-a)*本次采样值+a*上次滤波结果。</span></span><br><span class="line"><span class="comment">优点：  对周期性干扰具有良好的抑制作用；</span></span><br><span class="line"><span class="comment">        适用于波动频率较高的场合。</span></span><br><span class="line"><span class="comment">       平滑度高，适于高频振荡的系统。</span></span><br><span class="line"><span class="comment">缺点： 相位滞后，灵敏度低；</span></span><br><span class="line"><span class="comment">      滞后程度取决于a值大小；</span></span><br><span class="line"><span class="comment">      不能消除滤波频率高于采样频率1/2的干扰信号。</span></span><br><span class="line"><span class="comment">******************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILTER7_A 0.01</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> Value;</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="title function_">filter7</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> NewValue;</span><br><span class="line">    Value    = table[b - <span class="number">1</span>];</span><br><span class="line">    NewValue = table[b];</span><br><span class="line">    b++;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">255</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Value = (<span class="type">int</span>)((<span class="type">float</span>)NewValue * FILTER7_A + (<span class="number">1.0</span> - FILTER7_A) * (<span class="type">float</span>)Value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************</span></span><br><span class="line"><span class="comment">方法八：加权递推平均滤波法</span></span><br><span class="line"><span class="comment">方法： 是对递推平均滤波法的改进，即不同时刻的数据加以不同的权；</span></span><br><span class="line"><span class="comment">       通常是，越接近现时刻的数据，权取得越大。</span></span><br><span class="line"><span class="comment">       给予新采样值的权系数越大，则灵敏度越高，但信号平滑度越低。</span></span><br><span class="line"><span class="comment">优点： 适用于有较大纯滞后时间常数的对象，和采样周期较短的系统。</span></span><br><span class="line"><span class="comment">缺点：  对于纯滞后时间常数较小、采样周期较长、变化缓慢的信号；</span></span><br><span class="line"><span class="comment">       不能迅速反应系统当前所受干扰的严重程度，滤波效果差。</span></span><br><span class="line"><span class="comment">******************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILTER8_N 12</span></span><br><span class="line"><span class="type">int</span> coe[FILTER8_N] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;;          <span class="comment">// 加权系数表</span></span><br><span class="line"><span class="type">int</span> sum_coe        = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">7</span> + <span class="number">8</span> + <span class="number">9</span> + <span class="number">10</span> + <span class="number">11</span> + <span class="number">12</span>; <span class="comment">// 加权系数和</span></span><br><span class="line"><span class="type">int</span> filter_buf[FILTER8_N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">filter8</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> filter_sum        = <span class="number">0</span>;</span><br><span class="line">    filter_buf[FILTER8_N] = table[a];</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">254</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; FILTER8_N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        filter_buf[i] = filter_buf[i + <span class="number">1</span>]; <span class="comment">// 数组元素左移，将第0个元素舍弃</span></span><br><span class="line">        filter_sum += filter_buf[i] * coe[i];</span><br><span class="line">    &#125;</span><br><span class="line">    filter_sum /= sum_coe;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, filter_sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************</span></span><br><span class="line"><span class="comment">方法九： 消抖滤波法</span></span><br><span class="line"><span class="comment">方法：  设置一个滤波计数器，将每次采样值与当前有效值比较：</span></span><br><span class="line"><span class="comment">       如果采样值 = 当前有效值，则计数器清零；</span></span><br><span class="line"><span class="comment">       如果采样值 &lt; 或 &gt; 当前有效值，则计数器+1，并判断计数器是否 &gt;= 上限N（溢出）；</span></span><br><span class="line"><span class="comment">       如果计数器溢出，则将本次值替换当前有效值，并清计数器。</span></span><br><span class="line"><span class="comment">优点：  对于变化缓慢的被测参数有较好的滤波效果；</span></span><br><span class="line"><span class="comment">        可避免在临界值附近控制器的反复开/关跳动或显示器上数值抖动。</span></span><br><span class="line"><span class="comment">缺点：  对于快速变化的参数不宜；</span></span><br><span class="line"><span class="comment">       如果在计数器溢出的那一次采样到的值恰好是干扰值,则会将干扰值当作有效值导入系统。</span></span><br><span class="line"><span class="comment">******************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILTER9_N 51</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> Value;</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="title function_">filter9</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> new_value;</span><br><span class="line">    Value     = table[b - <span class="number">1</span>];</span><br><span class="line">    new_value = table[b];</span><br><span class="line">    b++;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">255</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Value != new_value)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; FILTER9_N)</span><br><span class="line">        &#123;</span><br><span class="line">            i     = <span class="number">0</span>;</span><br><span class="line">            Value = new_value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************************************************</span></span><br><span class="line"><span class="comment">方法十：限幅消抖滤波法</span></span><br><span class="line"><span class="comment">方法： 相当于“限幅滤波法”+“消抖滤波法”；</span></span><br><span class="line"><span class="comment">       先限幅，后消抖。</span></span><br><span class="line"><span class="comment">优点：  继承了“限幅”和“消抖”的优点；</span></span><br><span class="line"><span class="comment">        改进了“消抖滤波法”中的某些缺陷，避免将干扰值导入系统。</span></span><br><span class="line"><span class="comment">缺点：   对于快速变化的参数不宜。</span></span><br><span class="line"><span class="comment">******************************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILTER10_A 51</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILTER10_N 5</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> Value;</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="title function_">filter10</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> NewValue;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> new_value;</span><br><span class="line">    Value    = table[b - <span class="number">1</span>];</span><br><span class="line">    NewValue = table[b];</span><br><span class="line">    b++;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">255</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (((NewValue - Value) &gt; FILTER10_A) || ((Value - NewValue) &gt; FILTER10_A))</span><br><span class="line">    &#123;</span><br><span class="line">        new_value = Value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        new_value = NewValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Value != new_value)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; FILTER10_N)</span><br><span class="line">        &#123;</span><br><span class="line">            i     = <span class="number">0</span>;</span><br><span class="line">            Value = new_value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief     主函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        filter1();</span><br><span class="line">        filter2();</span><br><span class="line">        filter3();</span><br><span class="line">        filter4();</span><br><span class="line">        filter5();</span><br><span class="line">        filter6();</span><br><span class="line">        filter7();</span><br><span class="line">        filter8();</span><br><span class="line">        filter9();</span><br><span class="line">        filter10();</span><br><span class="line">        Sleep(<span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ADC</category>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式之IIC协议及其相关</title>
    <url>/archives/2e946417.html</url>
    <content><![CDATA[<h2 id="IIC协议"><a href="#IIC协议" class="headerlink" title="IIC协议"></a><code>IIC</code>协议</h2><p><strong>协议：</strong><br>协议简单来说就是主机与从机双方约定一组动作，只要一方做了特定的动作，另一方就可以知道你要干什么，然后就可以给出特定的回复动作，多次重复就可以实现通信。</p>
<span id="more"></span>

<p><strong>以下是我总结的<code>IIC</code>读写的步骤，仅供参考：</strong><br><strong><code>IIC</code> 读数据:</strong><br>发送起始信号<br>发送从机地址 - 发送（写入）<br>发送寄存器地址<br>起始信号<br>发送从机地址 - 接收（读取）<br>接收数据<br>发送停止信号</p>
<p><strong><code>IIC</code> 写数据:</strong><br>发送起始信号<br>发送从机地址 - 发送（写入）<br>发送寄存器地址<br>发送数据<br>发送停止信号</p>
<h2 id="软件模拟IIC实现与硬件IIC"><a href="#软件模拟IIC实现与硬件IIC" class="headerlink" title="软件模拟IIC实现与硬件IIC"></a>软件模拟<code>IIC</code>实现与硬件<code>IIC</code></h2><p>由于在<code>IIC</code>总线的通信过程中，时钟信号由主设备产生，从设备根据时钟信号进行数据传输（即同步通信）。故可通过代码方便地模拟该协议，也即所谓的模拟<code>IIC</code>协议。<br>不过，对于异步通信来说，软件就没办法进行模拟了，比如常见的串口通信。</p>
<p>在软件模拟 <code>IIC</code> 时 <code>GPIO</code> <strong>一般为开漏模式</strong>，支持线与功能；不过由于开漏模式无法输出真正的高电平，所以需要外部上拉（<code>IIC</code>的电平只是通信使用，所以负载强度不大；一般总线上认为，低于<code>0.3Vdd</code>为低电平，高于<code>0.7Vdd</code>为高电平）<br>推挽输出不能实现线与功能，因为如果两个输出引脚，一个输出高电平<code>P-MOS</code>管导通，一个输出低电平<code>N-MOS</code>管导通，则<code>P-MOS</code>管上方的高电平会经过<code>P-MOS -&gt; N-MOS -&gt; GND</code>，整个通路上没有外接电阻，因此电阻很小相当于高电平直接接到低电平造成了短路。</p>
<p>模拟 <code>I2C </code>是用两条 <code>GPIO </code>管脚的软件模拟的，将一个 <code>GPIO </code>设置为数据线 <code>SDA</code>，另外一个设置为时钟线 <code>SCL</code>。<br>硬件 <code>I2C </code>则是通过一个 <code>I2C </code>控制器实现的，该控制器被建立在微控制器芯片或单独的 <code>I2C </code>芯片中，通过集成的硬件内部逻辑和电路来控制时序和数据格式，实现 <code>I2C </code>总线通信。<br>软件与硬件的<code>IIC</code>各有优缺点，可根据实际情况选用。</p>
<p><strong>注：</strong>在使用软件模拟<code>IIC</code>时，其实<code>IIC</code>的<code>IO</code>口既可以配置为推挽输出也可以配置为开漏输出，不同之处在于当<code>IO</code>口配置为推挽输出时，发送和接收数据时需要切换<code>IO</code>口的输入输出模式，发送数据时需要将<code>IO</code>口切换为输出模式，接收数据时需要将<code>IO</code>口切换为输入模式。如果配置开漏输出则不需要切换<code>IO</code>口的输入输出模式。我们知道推挽输出不具有线与的功能，但是由于我们使用软件<code>IIC</code>时通常不会有多个设备连接到一个总线上的情况，所以只有一个从设备的话，也就不会有线与的情况发生了，可以使用推挽输出。但是我们需要根据发送数据和接收数据来切换<code>IO</code>口的工作模式。</p>
<h3 id="模拟IIC代码实现"><a href="#模拟IIC代码实现" class="headerlink" title="模拟IIC代码实现"></a>模拟<code>IIC</code>代码实现</h3><blockquote>
<p><strong>注：有时候器件规格书上标明的设备地址不一定非得按照该地址进行寻址！</strong></p>
<p><strong>具体来说就是，假如：现有一传感器，使用<code>IIC</code>通信；其规格书标明设备地址可选<code>（0x18、0x19）</code>，假如根据硬件连接，我们选用的地址为<code>0x18</code>；这并不意味着我们寻址是直接使用<code>#define SLAVE_ADDR 0x18</code>就行，很可能需要进行一番运算，即：<code>#define SLAVE_ADDR (0x18 &lt;&lt; 1)</code>。如果<code>IIC</code>使用7位地址，那么<code>&lt;&lt; 1</code>的作用就很明了了：将最低位让出，用做读写位。</strong></p>
<p><strong>所以如果使用<code>IIC</code>时，根据规格书上的地址寻不到从设备且检查并无其他问题，那么就可以考虑一下该情况！</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函    数：I2C写SCL引脚电平</span></span><br><span class="line"><span class="comment"> * 参    数：BitValue 协议层传入的当前需要写入SCL的电平，范围0~1</span></span><br><span class="line"><span class="comment"> * 返 回 值：无</span></span><br><span class="line"><span class="comment"> * 注意事项：此函数需要用户实现内容，当BitValue为0时，需要置SCL为低电平，当BitValue为1时，需要置SCL为高电平</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SCL</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(GPIOB, GPIO_Pin_10, (BitAction)BitValue); <span class="comment">// 根据BitValue，设置SCL引脚的电平</span></span><br><span class="line">    Delay_us(<span class="number">10</span>);                                           <span class="comment">// 延时10us，防止时序频率超过要求</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函    数：I2C写SDA引脚电平</span></span><br><span class="line"><span class="comment"> * 参    数：BitValue 协议层传入的当前需要写入SDA的电平，范围0~0xFF</span></span><br><span class="line"><span class="comment"> * 返 回 值：无</span></span><br><span class="line"><span class="comment"> * 注意事项：此函数需要用户实现内容，当BitValue为0时，需要置SDA为低电平，当BitValue非0时，需要置SDA为高电平</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_W_SDA</span><span class="params">(<span class="type">uint8_t</span> BitValue)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_WriteBit(GPIOB, GPIO_Pin_11, (BitAction)BitValue); <span class="comment">// 根据BitValue，设置SDA引脚的电平，BitValue要实现非0即1的特性</span></span><br><span class="line">    Delay_us(<span class="number">10</span>);                                           <span class="comment">// 延时10us，防止时序频率超过要求</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函    数：I2C读SDA引脚电平</span></span><br><span class="line"><span class="comment"> * 参    数：无</span></span><br><span class="line"><span class="comment"> * 返 回 值：协议层需要得到的当前SDA的电平，范围0~1</span></span><br><span class="line"><span class="comment"> * 注意事项：此函数需要用户实现内容，当前SDA为低电平时，返回0，当前SDA为高电平时，返回1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_R_SDA</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> BitValue;</span><br><span class="line">    BitValue = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11); <span class="comment">// 读取SDA电平</span></span><br><span class="line">    Delay_us(<span class="number">10</span>);                                         <span class="comment">// 延时10us，防止时序频率超过要求</span></span><br><span class="line">    <span class="keyword">return</span> BitValue;                                      <span class="comment">// 返回SDA电平</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函    数：I2C初始化</span></span><br><span class="line"><span class="comment"> * 参    数：无</span></span><br><span class="line"><span class="comment"> * 返 回 值：无</span></span><br><span class="line"><span class="comment"> * 注意事项：此函数需要用户实现内容，实现SCL和SDA引脚的初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*开启时钟*/</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); <span class="comment">// 开启GPIOB的时钟</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*GPIO初始化*/</span></span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;</span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;</span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOB, &amp;GPIO_InitStructure); <span class="comment">// 将PB10和PB11引脚初始化为开漏输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置默认电平*/</span></span><br><span class="line">    GPIO_SetBits(GPIOB, GPIO_Pin_10 | GPIO_Pin_11); <span class="comment">// 设置PB10和PB11引脚初始化后默认为高电平（释放总线状态）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函    数：I2C起始</span></span><br><span class="line"><span class="comment"> * 参    数：无</span></span><br><span class="line"><span class="comment"> * 返 回 值：无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyI2C_W_SDA(<span class="number">1</span>); <span class="comment">// 释放SDA，确保SDA为高电平</span></span><br><span class="line">    MyI2C_W_SCL(<span class="number">1</span>); <span class="comment">// 释放SCL，确保SCL为高电平</span></span><br><span class="line">    MyI2C_W_SDA(<span class="number">0</span>); <span class="comment">// 在SCL高电平期间，拉低SDA，产生起始信号</span></span><br><span class="line">    MyI2C_W_SCL(<span class="number">0</span>); <span class="comment">// 起始后把SCL也拉低，即为了占用总线，也为了方便总线时序的拼接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函    数：I2C终止</span></span><br><span class="line"><span class="comment"> * 参    数：无</span></span><br><span class="line"><span class="comment"> * 返 回 值：无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyI2C_W_SDA(<span class="number">0</span>); <span class="comment">// 拉低SDA，确保SDA为低电平</span></span><br><span class="line">    MyI2C_W_SCL(<span class="number">1</span>); <span class="comment">// 释放SCL，使SCL呈现高电平</span></span><br><span class="line">    MyI2C_W_SDA(<span class="number">1</span>); <span class="comment">// 在SCL高电平期间，释放SDA，产生终止信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函    数：I2C发送一个字节</span></span><br><span class="line"><span class="comment"> * 参    数：Byte 要发送的一个字节数据，范围：0x00~0xFF</span></span><br><span class="line"><span class="comment"> * 返 回 值：无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) <span class="comment">// 循环8次，主机依次发送数据的每一位</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyI2C_W_SDA(Byte &amp; (<span class="number">0x80</span> &gt;&gt; i)); <span class="comment">// 使用掩码的方式取出Byte的指定一位数据并写入到SDA线</span></span><br><span class="line">        MyI2C_W_SCL(<span class="number">1</span>);                  <span class="comment">// 释放SCL，从机在SCL高电平期间读取SDA</span></span><br><span class="line">        MyI2C_W_SCL(<span class="number">0</span>);                  <span class="comment">// 拉低SCL，主机开始发送下一位数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函    数：I2C接收一个字节</span></span><br><span class="line"><span class="comment"> * 参    数：无</span></span><br><span class="line"><span class="comment"> * 返 回 值：接收到的一个字节数据，范围：0x00~0xFF</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveByte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i, Byte = <span class="number">0x00</span>; <span class="comment">// 定义接收的数据，并赋初值0x00，此处必须赋初值0x00，后面会用到</span></span><br><span class="line">    MyI2C_W_SDA(<span class="number">1</span>);         <span class="comment">// 接收前，主机先确保释放SDA，避免干扰从机的数据发送</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) <span class="comment">// 循环8次，主机依次接收数据的每一位</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyI2C_W_SCL(<span class="number">1</span>); <span class="comment">// 释放SCL，主机在SCL高电平期间读取SDA</span></span><br><span class="line">        <span class="keyword">if</span> (MyI2C_R_SDA() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Byte |= (<span class="number">0x80</span> &gt;&gt; i);</span><br><span class="line">        &#125; <span class="comment">// 读取SDA数据，并存储到Byte变量</span></span><br><span class="line">          <span class="comment">// 当SDA为1时，置变量指定位为1，当SDA为0时，不做处理，指定位为默认的初值0</span></span><br><span class="line">        MyI2C_W_SCL(<span class="number">0</span>); <span class="comment">// 拉低SCL，从机在SCL低电平期间写入SDA</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Byte; <span class="comment">// 返回接收到的一个字节数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函    数：I2C发送应答位</span></span><br><span class="line"><span class="comment"> * 参    数：Byte 要发送的应答位，范围：0~1，0表示应答，1表示非应答</span></span><br><span class="line"><span class="comment"> * 返 回 值：无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyI2C_SendAck</span><span class="params">(<span class="type">uint8_t</span> AckBit)</span></span><br><span class="line">&#123;</span><br><span class="line">    MyI2C_W_SDA(AckBit); <span class="comment">// 主机把应答位数据放到SDA线</span></span><br><span class="line">    MyI2C_W_SCL(<span class="number">1</span>);      <span class="comment">// 释放SCL，从机在SCL高电平期间，读取应答位</span></span><br><span class="line">    MyI2C_W_SCL(<span class="number">0</span>);      <span class="comment">// 拉低SCL，开始下一个时序模块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函    数：I2C接收应答位</span></span><br><span class="line"><span class="comment"> * 参    数：无</span></span><br><span class="line"><span class="comment"> * 返 回 值：接收到的应答位，范围：0~1，0表示应答，1表示非应答</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">MyI2C_ReceiveAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> AckBit;         <span class="comment">// 定义应答位变量</span></span><br><span class="line">    MyI2C_W_SDA(<span class="number">1</span>);         <span class="comment">// 接收前，主机先确保释放SDA，避免干扰从机的数据发送</span></span><br><span class="line">    MyI2C_W_SCL(<span class="number">1</span>);         <span class="comment">// 释放SCL，主机机在SCL高电平期间读取SDA</span></span><br><span class="line">    AckBit = MyI2C_R_SDA(); <span class="comment">// 将应答位存储到变量里</span></span><br><span class="line">    MyI2C_W_SCL(<span class="number">0</span>);         <span class="comment">// 拉低SCL，开始下一个时序模块</span></span><br><span class="line">    <span class="keyword">return</span> AckBit;          <span class="comment">// 返回定义应答位变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函    数：读取从机数据</span></span><br><span class="line"><span class="comment"> * 参数1：   从机地址</span></span><br><span class="line"><span class="comment"> * 参数2：   指向存放读取数据的地址</span></span><br><span class="line"><span class="comment"> *参数3：    读取长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C_Read_Data</span><span class="params">(<span class="type">uint8_t</span> Address, <span class="type">uint8_t</span> *Buffer, <span class="type">uint16_t</span> Length)</span></span><br><span class="line">&#123;</span><br><span class="line">    My_I2C_Start();</span><br><span class="line">    My_I2C_WriteByte(Address); <span class="comment">// 器件地址</span></span><br><span class="line">    <span class="keyword">if</span> (My_I2C_GetACK())</span><br><span class="line">    &#123;</span><br><span class="line">        My_I2C_Stop();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    My_I2C_WriteByte(<span class="number">0x00</span>); <span class="comment">// 寄存器地址</span></span><br><span class="line">    <span class="keyword">if</span> (My_I2C_GetACK())</span><br><span class="line">    &#123;</span><br><span class="line">        My_I2C_Stop();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    My_I2C_Start();</span><br><span class="line">    My_I2C_WriteByte(Address + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (My_I2C_GetACK())</span><br><span class="line">    &#123;</span><br><span class="line">        My_I2C_Stop();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *Buffer++ = My_I2C_ReadByte();</span><br><span class="line">        <span class="keyword">if</span> (--Length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        My_I2C_PutACK(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        My_I2C_PutACK(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    My_I2C_Stop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="硬件IIC通信示例"><a href="#硬件IIC通信示例" class="headerlink" title="硬件IIC通信示例"></a>硬件IIC通信示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">My_IIC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rcu_periph_clock_enable(RCU_I2C1);</span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOB);</span><br><span class="line"></span><br><span class="line">    gpio_af_set(GPIOB, GPIO_AF_1, GPIO_PIN_10);</span><br><span class="line">    gpio_af_set(GPIOB, GPIO_AF_1, GPIO_PIN_11);</span><br><span class="line"></span><br><span class="line">    gpio_mode_set(GPIOB, GPIO_MODE_AF, GPIO_PUPD_PULLUP, GPIO_PIN_10);             <span class="comment">// SCL</span></span><br><span class="line">    gpio_output_options_set(GPIOB, GPIO_OTYPE_OD, GPIO_OSPEED_50MHZ, GPIO_PIN_10); <span class="comment">// 复用开漏</span></span><br><span class="line">    gpio_mode_set(GPIOB, GPIO_MODE_AF, GPIO_PUPD_PULLUP, GPIO_PIN_11);             <span class="comment">// SDA</span></span><br><span class="line">    gpio_output_options_set(GPIOB, GPIO_OTYPE_OD, GPIO_OSPEED_50MHZ, GPIO_PIN_11);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* configure I2C clock */</span></span><br><span class="line">    i2c_clock_config(I2C1, <span class="number">100000</span>, I2C_DTCY_2);</span><br><span class="line">    <span class="comment">/* configure I2C address */</span></span><br><span class="line">    i2c_mode_addr_config(I2C1, I2C_I2CMODE_ENABLE, I2C_ADDFORMAT_7BITS, OWN_ADDRESS7); <span class="comment">// 主机地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* enable I2C1 */</span></span><br><span class="line">    i2c_enable(I2C1);</span><br><span class="line">    <span class="comment">/* enable acknowledge */</span></span><br><span class="line">    i2c_ack_config(I2C1, I2C_ACK_ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Read_Data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> timeout = <span class="number">500</span>;</span><br><span class="line">    <span class="comment">/* 等IIC总线空闲 */</span></span><br><span class="line">    <span class="keyword">while</span> (i2c_flag_get(I2C1, I2C_FLAG_I2CBSY));</span><br><span class="line">    <span class="comment">/* 发送起始信号 */</span></span><br><span class="line">    i2c_start_on_bus(I2C1);</span><br><span class="line">    <span class="comment">/* 等到起始信号发送完毕 */</span></span><br><span class="line">    <span class="keyword">while</span> (!i2c_flag_get(I2C1, I2C_FLAG_SBSEND));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送从机地址 - 发送（写入） */</span></span><br><span class="line">    i2c_master_addressing(I2C1, SLA_ADDRESS7, I2C_TRANSMITTER); <span class="comment">// 从机地址</span></span><br><span class="line">    <span class="comment">/* 发送从机地址 - 若IIC从机在这儿会卡死，需添加返回操作 */</span></span><br><span class="line">    <span class="keyword">while</span> (!i2c_flag_get(I2C1, I2C_FLAG_ADDSEND))</span><br><span class="line">    &#123;</span><br><span class="line">        timeout--;</span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 发送结束信号 */</span></span><br><span class="line">            i2c_stop_on_bus(I2C1);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No I2C Device\r\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清除 I2C_FLAG_ADDSEND 标志位 */</span></span><br><span class="line">    i2c_flag_clear(I2C1, I2C_FLAG_ADDSEND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送寄存器地址 */</span></span><br><span class="line">    i2c_data_transmit(I2C1, REG_ADDRESS7); <span class="comment">// 寄存器地址</span></span><br><span class="line">    <span class="keyword">while</span> (!i2c_flag_get(I2C1, I2C_FLAG_BTC));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送起始信号 */</span></span><br><span class="line">    i2c_start_on_bus(I2C1);</span><br><span class="line">    <span class="comment">/* 等到起始信号发送完毕 */</span></span><br><span class="line">    <span class="keyword">while</span> (!i2c_flag_get(I2C1, I2C_FLAG_SBSEND));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送从机地址 - 接收（读取） */</span></span><br><span class="line">    i2c_master_addressing(I2C1, SLA_ADDRESS7, I2C_RECEIVER);</span><br><span class="line">    <span class="comment">/* 匹配从机地址 */</span></span><br><span class="line">    <span class="keyword">while</span> (!i2c_flag_get(I2C1, I2C_FLAG_ADDSEND));</span><br><span class="line">    <span class="comment">/* 清除 ADDSEND 标志位 */</span></span><br><span class="line">    i2c_flag_clear(I2C1, I2C_FLAG_ADDSEND);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取数据 - 9个字节 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; <span class="number">9</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">8</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* wait until the last data byte is received into the shift register */</span></span><br><span class="line">            <span class="keyword">while</span> (!i2c_flag_get(I2C1, I2C_FLAG_BTC));</span><br><span class="line">            <span class="comment">/* 失能应答 */</span></span><br><span class="line">            i2c_ack_config(I2C1, I2C_ACK_DISABLE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* wait until the RBNE bit is set */</span></span><br><span class="line">        <span class="keyword">while</span> (!i2c_flag_get(I2C1, I2C_FLAG_RBNE));</span><br><span class="line">        <span class="comment">/* read a data from I2C_DATA */</span></span><br><span class="line">        i2c_recv_buf[index] = i2c_data_receive(I2C1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送结束信号 */</span></span><br><span class="line">    i2c_stop_on_bus(I2C1);</span><br><span class="line">    <span class="comment">/* 等到结束信号发送完毕 */</span></span><br><span class="line">    <span class="keyword">while</span> (I2C_CTL0(I2C1) &amp; I2C_CTL0_STOP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使能应答 */</span></span><br><span class="line">    i2c_ack_config(I2C1, I2C_ACK_ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>根据传输的数据位来拉<code>SCL</code>与<code>SDA</code>线电平：若为逻辑1，则拉高<code>SCL</code>与<code>SDA</code>线电平，若为逻辑0就拉低</li>
<li><code>SCL</code>与<code>SDA</code>需默认<strong>拉高</strong>，以<strong>释放总线状态</strong>，此时为准备好数据传输状态</li>
<li><code>IIC</code>起始信号：<code>SCL</code>高电平，<code>SDA</code>下降沿<strong>（注：起始后需把<code>SCL</code>也拉低，使主机占用总线准备发送数据）</strong>；<code>IIC</code>结束信号：<code>SCL</code>高电平，<code>SDA</code>上升沿；</li>
<li>主机发送：每次发送1位，循环8次即可发送一个字节；在发送数据时应注意：<code>SCL</code>高电平时，此时<code>SDA</code>上数据有效，不可被更改；<code>SCL</code>低电平时，<code>SDA</code>上数据可被更改，也只有这时数据可被更改</li>
<li>从机接收：在接收前，应先拉高<code>SDA</code>，避免主机抢占<code>SDA</code>，导致数据出错；为存储接收到的数据，需拉高<code>SCL</code>，使主机在<code>SCL</code>高电平期间读取<code>SDA</code>，每读取一位就存入提前申请好的变量中；读完后即可得到一个字节的数据。然后拉低<code>SCL</code>，使从机可写入<code>SDA</code>，这样即可实现从机发送。</li>
<li>应答信号：主机把应答位数据放到<code>SDA</code>线（即：如需应答则拉低<code>SDA</code>，如无需应答则拉高<code>SDA</code>）；然后先拉高<code>SCL</code>，以读取应答位；再拉低<code>SCL</code>，开始下一个时序模块；</li>
</ol>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="推挽输出"><a href="#推挽输出" class="headerlink" title="推挽输出"></a>推挽输出</h3><p>推挽（<code>Push-Pull</code>）通常用于需要强驱动能力的场景。<br>推挽输出既可以向负载灌电流，也可以从负载抽取电流。推拉式输出既提高电路的负载能力，又提高开关速度。<br>下面是一个典型的推挽输出电路：上面的三极管是<code>NPN</code>型三极管，下面的三极管是<code>PNP</code>型三极管，分别有以下两种情况，请留意控制端、输入端和输出端。</p>
<p><strong>输出低电平：从负载拉电流</strong><br><img src="https://s2.loli.net/2024/11/26/5OriGa6uAQ4soPM.png" alt="推挽输出_低"><br>当<code>Vin</code>电压为<code>V-</code>时，下面的三极管有电流流出，<code>Q4</code>导通，<code>Q3</code>截止，于是电流从上往下流过。经过下面的<code>P</code>型三极管提供电流给负载（<code>Rload</code>)，这就叫「挽」。</p>
<p><strong>输出高电平：向负载灌电流</strong><br><img src="https://s2.loli.net/2024/11/26/muhy6SWHCl3IfUw.png" alt="推挽输出_高"><br>当<code>Vin</code>电压为<code>V+</code>时，上面的N型三极管控制端有电流输入，<code>Q3</code>导通，<code>Q4</code>截止，于是电流从上往下通过，提供电流给负载。经过上面的N型三极管提供电流给负载（<code>Rload</code>)，这就叫「推」。</p>
<h3 id="开漏输出（开集输出）"><a href="#开漏输出（开集输出）" class="headerlink" title="开漏输出（开集输出）"></a>开漏输出（开集输出）</h3><p>开漏输出指的是场效应管（可以类比晶体管来理解，对于晶体管来说，也就变成了开集电极输出）的漏极开路输出，只能输出低电平和高阻态（只有接上拉电阻才能输出高电平）。</p>
<p>以下图为例，当内部输出为1时，经过非门变为0，也就是场效应管的栅极电压为0，此时场效应管截止（相当于开路），那么单片机<code>IO</code>的输出是什么呢？是没办法确定的，注意并没有上拉电路。如果有上拉电阻呢，当然就是<code>VCC</code>，也就是逻辑1。当内部输出0时，栅极电压为1，此时场效应管导通，单片机<code>IO</code>与地连接，输出为0。<br><img src="https://www.stmcu.org.cn/module/forum/data/attachment/forum/202103/11/132526zq8ev8xn8ncv0xz2.png" alt="开漏输出"></p>
<p>开漏结构（<code>OD</code>）对比推挽结构：开漏结构只有一个三极管或者<code>MOS</code>管，推挽结构则有两个。<br>之所以叫开漏，是因为<code>MOS</code>管分为三极：源极、栅极、漏极。漏极开路输出，所以叫开漏输出；<br>如果是三极管：基极、集电极、发射极，集电极开路输出，就叫开集输出（<code>OC</code>）。</p>
<h3 id="浮空输入"><a href="#浮空输入" class="headerlink" title="浮空输入"></a>浮空输入</h3><p>顾名思义，浮空就是浮在空中，既不上拉也不下拉；<br>通俗讲就是让管脚什么都不接，浮空着，呈高阻态。<br>浮空最大的特点就是电压的不确定性，它可能是<code>0V</code>，也可能是<code>VCC</code>，还可能是介于两者之间的某个值（最有可能）完全由外部输入决定，引脚悬空的情况下，该端口的电平是不确定的。</p>
<p>用途：</p>
<ul>
<li>浮空可用来做<code>ADC</code>输入，这样可以减少上下拉电阻对结果的影响。</li>
<li>用于外部按键输入。</li>
</ul>
<h3 id="高阻态"><a href="#高阻态" class="headerlink" title="高阻态"></a>高阻态</h3><p>高阻状态是三态门电路的一种状态，三态为高电平、低电平、高阻态。<br>当处于高阻态时，无论该门的输入如何变化，都不会对其输出有影响。<br>高阻态近似为开路状态，控制信号无法控制引脚的电平，引脚测量电压可能为任意的电压值。</p>
<h3 id="上拉-amp-下拉"><a href="#上拉-amp-下拉" class="headerlink" title="上拉 &amp; 下拉"></a>上拉 &amp; 下拉</h3><p>上拉就是将引脚通过一个电阻连接到<code>VCC</code>上；<br>上拉电阻的功能主要是为集电极开路输出型电路和开漏输出提供输出电流通道，将不确定的信号通过一个电阻钳位在高电平（可以结合上面的开漏输出来理解），电阻同时起限流作用。<br>所谓的强上拉、弱上拉，只是上拉电阻的阻值不同。</p>
<p>下拉就是将引脚通过一个电阻连接到<code>GND</code>上，将不确定的信号通过一个电阻钳位在低电平。</p>
<h3 id="三极管-amp-场效应管"><a href="#三极管-amp-场效应管" class="headerlink" title="三极管 &amp; 场效应管"></a>三极管 &amp; 场效应管</h3><p><strong>三个极：</strong><br>三极管是半导体基本元器件之一，具有电流放大作用；<br>共有三个极：发射极（<code>Emitter</code>）、基极（<code>Base</code>）和集电极（<code>Collector</code>）；中间部分是基区，两侧部分是发射区和集电区，排列方式有<code>PNP</code>和<code>NPN</code>两种。<br>场效应管有三个极：源极（<code>S - Source</code>），栅极（<code>G - Gate</code>），漏极（<code>D - Drain</code>），对应于晶体管的发射极（<code>E</code>），基极（<code>B</code>），以及集电极（<code>C</code>），排列方式也有<code>P</code>沟道和<code>N</code>沟道两种。</p>
<p><code>MOS</code>管的源极和漏极是可以对调的，他们都是在<code>P</code>型<code>backgate</code>中形成的<code>N</code>型区。在多数情况下，这个两个区是一样的，即使两端对调也不会影响器件的性能，这样的器件被认为是对称的。</p>
<p><code>N-MOS</code>的特性，<code>Vgs </code>大于一定的值就会导通，适合用于源极接地时的情况（低端驱动）。<br><code>P-MOS</code>的特性，<code>Vgs </code>小于一定的值就会导通，适合用于源极接 <code>VCC </code>时的情况（高端驱动）。</p>
<p><strong>三极管与场效应管的基本工作原理：</strong></p>
<ul>
<li>‌<strong>三极管</strong>‌：三极管是一种电流控制元件，其工作原理是通过控制输入电流来改变输出电流。三极管有<code>NPN</code>型和<code>PNP</code>型两种类型，电流方向不同‌。</li>
<li><strong>场效应管</strong>‌：场效应管是一种电压控制元件，通过控制输入电压来改变输出电流。场效应管分为结型场效应管和金属氧化物场效应管（<code>MOS</code>管），其中<code>MOS</code>管是最常见的类型‌。</li>
</ul>
<p><strong>三极管与场效应管的主要区别：</strong></p>
<ol>
<li>‌<strong>控制方式</strong>‌：三极管是电流控制元件，需要输入电流才能产生输出电流；而场效应管是电压控制元件，输入端电流极小，适用于低功耗应用‌。</li>
<li>‌<strong>输入阻抗</strong>‌：三极管的输入阻抗较小，而场效应管的输入阻抗较大，适用于高输入电阻的场合‌。</li>
<li>‌<strong>噪声性能</strong>‌：场效应管的噪声系数较低，适用于低噪声放大器的前置级‌。</li>
<li>‌<strong>温度特性</strong>‌：三极管是负温度系数器件，而场效应管是正温度系数器件，场效应管在高温下功耗增加，可能导致更高的温度‌。</li>
<li>‌<strong>开关频率</strong>‌：场效应管的开关频率高于三极管，适用于高速开关应用‌。</li>
</ol>
<p><strong>应用场景：</strong></p>
<ul>
<li>‌<strong>三极管</strong>‌：适用于低频放大、开关电路和功率放大等应用。</li>
<li>‌<strong>场效应管</strong>‌：适用于高频放大、低噪声放大、开关电路和低功耗电路等‌。</li>
</ul>
<h3 id="线与"><a href="#线与" class="headerlink" title="线与"></a>线与</h3><p>线与：所有<code>GPIO</code>输出高就是高，只要有一个输出低，整条线上面的都是低，这就是“与”的意思。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote>
<p><a href="https://www.elecfans.com/d/2192185.html">I2C推挽结构和开漏结构 - 电子发烧友</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/589281270">从IIC看推挽输出和开漏输出 - 知乎</a></p>
<p><a href="https://www.cnblogs.com/Sandals-little/p/18002041">推挽输出和开漏输出 - 博客园</a></p>
<p><a href="https://www.stmcu.org.cn/module/forum/forum.php?mod=viewthread&tid=629412">推挽、开漏等概念总结 - STM32社区</a></p>
<p><a href="https://blog.csdn.net/qq_42992084/article/details/98784963">三极管 - CSDN</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/50357150">认识场效应管MOSFET - 知乎</a></p>
<p><a href="https://www.cnblogs.com/muyi23333/articles/13475929.html">管脚复用功能之 上拉、下拉、模拟、浮空输入；推挽、开漏、复用输出 - 博客园</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/687626500">嵌入式软件学习之单片机篇 GPIO - 知乎</a></p>
</blockquote>
]]></content>
      <categories>
        <category>IIC协议</category>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>IIC协议</tag>
        <tag>三极管</tag>
        <tag>场效应管</tag>
      </tags>
  </entry>
  <entry>
    <title>OrangePi zero 3</title>
    <url>/archives/3f4f88f3.html</url>
    <content><![CDATA[<h1 id="OrangePi-ZERO-3"><a href="#OrangePi-ZERO-3" class="headerlink" title="OrangePi ZERO 3"></a>OrangePi ZERO 3</h1><p>最近刷视频突然有了个买块开发板的念头，而且这个念头一形成就挥之不去；忍耐了几周，终于还是下手了！</p>
<p>由于是第一次买Orangepi，且网上关于Orangepi的资料也不如Raspberry pi，故记录一下使用过程，方便之后查阅。</p>
<h2 id="刷-Ubuntu-系统"><a href="#刷-Ubuntu-系统" class="headerlink" title="刷 Ubuntu 系统"></a>刷 <code>Ubuntu</code> 系统</h2><p>参照网上教程，不多赘述</p>
<p>不过需注意一点：要找适合自己开发板内存的系统镜像</p>
<p>刷完使用串口线连接电脑与板子即可，我使用的工具是：<a href="https://mobaxterm.mobatek.net/download.html">MobaXterm</a></p>
<span id="more"></span>

<h2 id="部署博客"><a href="#部署博客" class="headerlink" title="部署博客"></a>部署博客</h2><h3 id="开发板架构"><a href="#开发板架构" class="headerlink" title="开发板架构"></a>开发板架构</h3><p>刷完系统先看下镜像版本与开发板 <code>CPU</code> 架构</p>
<ul>
<li>查看版本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsb_release -a	</span><br></pre></td></tr></table></figure>

<ul>
<li>查看架构</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -m （或 arch）		</span><br></pre></td></tr></table></figure>

<p>返回参数说明：</p>
<ul>
<li><p>x86_64、x64、AMD64 是同一个东西，都为x86架构；</p>
</li>
<li><p>aarch64 是 ARM 架构的 64 位版本</p>
</li>
</ul>
<p>要根据架构选择对应的源！否则在 <code>sudo apt update</code> 时会出错！</p>
<p>（若开发板的cpu是arm架构，默认匹配都是x86架构处理器的软件包，用错源会找不到所需的包信息，就会报错）</p>
<h3 id="连接WiFi"><a href="#连接WiFi" class="headerlink" title="连接WiFi"></a>连接WiFi</h3><p>若接了网线可跳过此步</p>
<ul>
<li>查看附近所有wifi</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmcli dev wifi list	</span><br></pre></td></tr></table></figure>

<ul>
<li>连接wifi</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nmcli device wifi connect &quot;WiFi名称&quot; password &quot;密码&quot;	</span><br></pre></td></tr></table></figure>

<ul>
<li>查看连接wifi后的ip，方便之后连接SSH</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig	</span><br></pre></td></tr></table></figure>

<h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><p>我刷的系统为 Ubuntu 22.04，不同版本系统可能会有差异，可百度对应版本换源方法；此处以22.04为例：</p>
<ul>
<li>先备份</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bk	</span><br></pre></td></tr></table></figure>

<ul>
<li>修改</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>将以下内容覆盖即可：</p>
<p>此处用的是 <a href="https://mirrors.ustc.edu.cn/help/ubuntu-ports.html">中科大源</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认注释了源码仓库，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ jammy main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ jammy main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ jammy-security main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ jammy-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ jammy-updates main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ jammy-updates main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ jammy-backports main restricted universe multiverse</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ jammy-backports main restricted universe multiverse</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">预发布软件源，不建议启用</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb https://mirrors.ustc.edu.cn/ubuntu-ports/ jammy-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">deb-src https://mirrors.ustc.edu.cn/ubuntu-ports/ jammy-proposed main restricted universe multiverse</span></span><br></pre></td></tr></table></figure>

<h3 id="改时区"><a href="#改时区" class="headerlink" title="改时区"></a>改时区</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo orangepi-config</span><br></pre></td></tr></table></figure>

<p>找到 <code>timezone</code> ，改为 <code>Asia</code> <code>shanghai</code> 保存并退出即可</p>
<ul>
<li>查看系统日期及时间</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date</span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>依次执行即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<h3 id="部署-hexo-博客"><a href="#部署-hexo-博客" class="headerlink" title="部署 hexo 博客"></a>部署 <code>hexo</code> 博客</h3><p>参考文章<a href="https://zhuanlan.zhihu.com/p/402382426">用树莓派服务器运行Hexo博客网页 - 知乎</a></p>
<p>跟着上面文章来就行，我这里简单记录一下使用到的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -p 22 orangepi@192.168.10.11</span><br></pre></td></tr></table></figure>

<ul>
<li>安装git</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<ul>
<li>查看是否安装成功</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<ul>
<li>安装nginx</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>查看是否安装成功</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure>

<ul>
<li>其他</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /var/repo/</span><br><span class="line">sudo chown -R $USER:$USER /var/repo/</span><br><span class="line">sudo chmod -R 755 /var/repo/</span><br><span class="line">cd /var/repo/</span><br><span class="line">git init --bare web_blog.git</span><br><span class="line">sudo mkdir -p /var/www/hexo</span><br><span class="line">sudo chown -R $USER:$USER /var/www/hexo</span><br><span class="line">sudo chmod -R 755 /var/www/hexo</span><br></pre></td></tr></table></figure>

<ul>
<li>脚本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /var/repo/web_blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<p>填写如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">git --work-tree=/var/www/hexo --git-dir=/var/repo/web_blog.git checkout -f</span><br></pre></td></tr></table></figure>

<ul>
<li>赋予脚本可执行权限</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod +x /var/repo/web_blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<ul>
<li>修改nginx配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/nginx/sites-available/default</span><br></pre></td></tr></table></figure>

<p>将其中路径改为你自己的hexo目录的路径</p>
<ul>
<li>重启nginx即可</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure>

<h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>因为我还有个服务器，故这里直接用frp穿透</p>
<p>赋予可执行权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x frpc</span><br></pre></td></tr></table></figure>

<p>贴一下frpc.ini的配置内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = #服务器外网IP</span><br><span class="line">server_port = 7000</span><br><span class="line">authentication_method = token</span><br><span class="line">token = #自己设个密码</span><br><span class="line"></span><br><span class="line">[SSH]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line">[Web]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 80</span><br><span class="line">remote_port = 3000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使其开机自启</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/frpc.service</span><br></pre></td></tr></table></figure>

<p>填入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=FRP Client Service</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=3</span><br><span class="line">ExecStart=/home/orangepi/frp/frpc -c /home/orangepi/frp/frpc.ini</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里应为自己frp路径</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<ul>
<li>使其生效</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重载</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自启</span></span><br><span class="line">sudo systemctl enable frpc.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">sudo systemctl start frpc.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行状态</span></span><br><span class="line">sudo systemctl status frpc.service</span><br></pre></td></tr></table></figure>

<h2 id="散热"><a href="#散热" class="headerlink" title="散热"></a>散热</h2><p>可以搞个 外壳+散热片+散热扇 淘宝有自己搜</p>
<ul>
<li>获取CPU温度</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /sys/class/thermal/thermal_zone0/temp</span><br></pre></td></tr></table></figure>

<p>上面的值除以1000即为CPU温度</p>
<p>有了CPU温度即可编程实现温度高于多少度则自动开风扇、低于多少度自动关；</p>
<p>哦，对了，可能需要个三极管来做开关；因为板子上引脚电压是没办法使用编程来控制高低电平的</p>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>在SOC上控制引脚与在单片机上略有不同</p>
<p>不过Orangepi zero 3自带了 WiringPi库可用来控制引脚，直接使用该库即可，库函数都封装好的，直接调用就好；</p>
<h3 id="外设"><a href="#外设" class="headerlink" title="外设"></a>外设</h3><p>我还买了DHT11与OLED屏用来检测并显示一些内容，代码也给贴一下，注释还是比较详细的：</p>
<p><strong>获取ip并输出到文件</strong></p>
<ul>
<li>创建脚本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim get_ip.sh</span><br></pre></td></tr></table></figure>

<p>脚本内容如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取IP地址</span></span><br><span class="line">IP_ADDRESS=$(ifconfig wlan0 | grep &quot;inet &quot; | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将IP地址保存到文件</span></span><br><span class="line">echo $IP_ADDRESS &gt; /home/orangepi/code/ip_adr.txt</span><br></pre></td></tr></table></figure>

<p>赋予脚本可执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chmod +x get_ip.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>定时执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10min执行一次，后边为脚本所在绝对路径</span></span><br><span class="line">*/10 * * * * /home/orangepi/code/get_ip.sh</span><br></pre></td></tr></table></figure>

<p><strong>整体C代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译：</span></span><br><span class="line"><span class="comment">gcc -O2 -Wall -Wextra -o sensor_app main.c -lwiringPi -lpthread</span></span><br><span class="line"><span class="comment">或</span></span><br><span class="line"><span class="comment">gcc main.c -o sensor_app -lwiringPi -lpthread</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">执行：</span></span><br><span class="line"><span class="comment">sudo ./sensor_app /dev/i2c-3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wiringPi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;font.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oled.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 硬件相关定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DHT11_PIN          8    <span class="comment">// DHT11 DATA引脚 15脚 PC8 IO-3</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_DEVICE_ADDR    0x3C <span class="comment">// OLED I2C地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPU_TEMP_PATH      <span class="string">&quot;/sys/class/thermal/thermal_zone0/temp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IP_ADDR_PATH       <span class="string">&quot;/home/orangepi/code/ip_adr.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WATCHDOG_TIMEOUT   10 <span class="comment">// 看门狗超时时间（秒）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILTER_WINDOW_SIZE 5  <span class="comment">// 滤波窗口大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局数据结构 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 传感器数据</span></span><br><span class="line">    <span class="type">float</span>         env_temp;</span><br><span class="line">    <span class="type">float</span>         cpu_temp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> humidity;</span><br><span class="line">    <span class="type">char</span>          ip_addr[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间数据</span></span><br><span class="line">    <span class="type">char</span> time_str[<span class="number">9</span>];</span><br><span class="line">    <span class="type">char</span> date_str[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 滤波数据</span></span><br><span class="line">    <span class="type">float</span>         temp_buffer[FILTER_WINDOW_SIZE];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> humi_buffer[FILTER_WINDOW_SIZE];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> filter_index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看门狗</span></span><br><span class="line">    <span class="type">time_t</span> last_update;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步锁</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">&#125; sensor_data_struct;</span><br><span class="line">sensor_data_struct sensor_data;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">display_info</span> <span class="title">disp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化GPIO */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_gpio</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (wiringPiSetup() == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to initialize wiringPi\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 温度滤波 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_filtered_temp</span><span class="params">(<span class="type">float</span> new_temp)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;sensor_data.lock);</span><br><span class="line"></span><br><span class="line">    sensor_data.temp_buffer[sensor_data.filter_index % FILTER_WINDOW_SIZE] = new_temp;</span><br><span class="line">    <span class="type">float</span> sum                                                              = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; FILTER_WINDOW_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += sensor_data.temp_buffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sensor_data.env_temp = sum / FILTER_WINDOW_SIZE;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;sensor_data.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 湿度滤波 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_filtered_humi</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> new_humi)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;sensor_data.lock);</span><br><span class="line"></span><br><span class="line">    sensor_data.humi_buffer[sensor_data.filter_index % FILTER_WINDOW_SIZE] = new_humi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sum                                                     = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; FILTER_WINDOW_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += sensor_data.humi_buffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sensor_data.humidity = sum / FILTER_WINDOW_SIZE;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;sensor_data.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取CPU温度 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_cpu_temp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> fd     = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span>       buf[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span> &amp;&amp; (fd = open(CPU_TEMP_PATH, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Open CPU temp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="keyword">sizeof</span>(buf)) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> temp = atoi(buf) / <span class="number">1000.0</span>;</span><br><span class="line">        pthread_mutex_lock(&amp;sensor_data.lock);</span><br><span class="line">        sensor_data.cpu_temp = temp;</span><br><span class="line">        pthread_mutex_unlock(&amp;sensor_data.lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取IP地址 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">read_ip_address</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">time_t</span> last_read = <span class="number">0</span>;</span><br><span class="line">    <span class="type">time_t</span>        now       = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now - last_read &gt; <span class="number">3600</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FILE* fp = fopen(IP_ADDR_PATH, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (fp)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;sensor_data.lock);</span><br><span class="line">            <span class="keyword">if</span> (fgets(sensor_data.ip_addr, <span class="keyword">sizeof</span>(sensor_data.ip_addr), fp) == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Failed to open ip_adr.txt\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;sensor_data.lock);</span><br><span class="line">            fclose(fp);</span><br><span class="line">            last_read = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读取DHT11数据 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_dht11</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span>   data[<span class="number">5</span>]   = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> max_retry = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>       retry     = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (retry = <span class="number">0</span>; retry &lt; max_retry; retry++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> timeout;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送启动信号</span></span><br><span class="line">        pinMode(DHT11_PIN, OUTPUT);</span><br><span class="line">        digitalWrite(DHT11_PIN, HIGH);</span><br><span class="line">        digitalWrite(DHT11_PIN, LOW);</span><br><span class="line">        delay(<span class="number">20</span>); <span class="comment">// 18ms &lt; 延时 &lt; 30ms</span></span><br><span class="line">        digitalWrite(DHT11_PIN, HIGH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待响应</span></span><br><span class="line">        pinMode(DHT11_PIN, INPUT);</span><br><span class="line">        pullUpDnControl(DHT11_PIN, PUD_UP);</span><br><span class="line">        delayMicroseconds(<span class="number">35</span>); <span class="comment">// 35us</span></span><br><span class="line">        timeout = micros();</span><br><span class="line">        <span class="keyword">while</span> (!digitalRead(DHT11_PIN))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (micros() - timeout &gt; <span class="number">250</span>) <span class="comment">// 250ms</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;nack1\n&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> OCCUR_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析并保存数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">char</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 等待 DHT11高电平通知主机准备接收数据 87us 结束</span></span><br><span class="line">                timeout = micros();</span><br><span class="line">                <span class="keyword">while</span> (digitalRead(DHT11_PIN))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (micros() - timeout &gt; <span class="number">250</span>) <span class="comment">// 250ms</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;nack2\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">goto</span> OCCUR_ERROR;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                timeout = micros();</span><br><span class="line">                <span class="comment">// 等待回复的54us低电平结束</span></span><br><span class="line">                <span class="keyword">while</span> (!digitalRead(DHT11_PIN))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (micros() - timeout &gt; <span class="number">250</span>) <span class="comment">// 250ms</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;nack3\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">goto</span> OCCUR_ERROR;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 接收回复的高电平  延时35us看是什么电平 - 高电平则发的为1，低电平发送的为0</span></span><br><span class="line">                delayMicroseconds(<span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保存数据</span></span><br><span class="line">                data[i] &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (digitalRead(DHT11_PIN) == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    data[i]++; <span class="comment">// 如果为1，则加上1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验</span></span><br><span class="line">        <span class="keyword">if</span> (data[<span class="number">4</span>] == (data[<span class="number">0</span>] + data[<span class="number">1</span>] + data[<span class="number">2</span>] + data[<span class="number">3</span>]))</span><br><span class="line">        &#123;</span><br><span class="line">            update_filtered_temp(data[<span class="number">2</span>] + data[<span class="number">3</span>] * <span class="number">0.1</span>);</span><br><span class="line">            update_filtered_humi(data[<span class="number">0</span>]);</span><br><span class="line">            sensor_data.filter_index++;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;TEMP:%.1f RH:%d\n&quot;</span>, data[<span class="number">2</span>] + data[<span class="number">3</span>] * <span class="number">0.1</span>, data[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    OCCUR_ERROR:</span><br><span class="line">        delay(<span class="number">250</span>); <span class="comment">// 重试间隔  250ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化OLED */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_oled</span><span class="params">(<span class="type">char</span>* i2c_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;disp, <span class="number">0</span>, <span class="keyword">sizeof</span>(disp));</span><br><span class="line">    disp.address = I2C_DEVICE_ADDR;</span><br><span class="line">    disp.font    = font2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oled_open(&amp;disp, i2c_dev) &lt; <span class="number">0</span> || oled_init(&amp;disp) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;OLED initialization failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时间更新 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_time_date</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span>     now     = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">tm_info</span> =</span> localtime(&amp;now);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;sensor_data.lock);</span><br><span class="line">    strftime(sensor_data.time_str, <span class="keyword">sizeof</span>(sensor_data.time_str), <span class="string">&quot;%H:%M&quot;</span>, tm_info);</span><br><span class="line">    strftime(sensor_data.date_str, <span class="keyword">sizeof</span>(sensor_data.date_str), <span class="string">&quot;%Y-%m-%d&quot;</span>, tm_info);</span><br><span class="line">    pthread_mutex_unlock(&amp;sensor_data.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示时间 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_time_screen</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> time_buf[<span class="number">16</span>], date_buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;sensor_data.lock);</span><br><span class="line">    <span class="built_in">strncpy</span>(time_buf, sensor_data.time_str, <span class="keyword">sizeof</span>(time_buf));</span><br><span class="line">    <span class="built_in">strncpy</span>(date_buf, sensor_data.date_str, <span class="keyword">sizeof</span>(date_buf));</span><br><span class="line">    pthread_mutex_unlock(&amp;sensor_data.lock);</span><br><span class="line"></span><br><span class="line">    disp.font = font2;</span><br><span class="line">    oled_putstrto(&amp;disp, <span class="number">0</span>, <span class="number">15</span>, time_buf);</span><br><span class="line">    oled_putstrto(&amp;disp, <span class="number">50</span>, <span class="number">15</span>, date_buf);</span><br><span class="line">    oled_send_buffer(&amp;disp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 显示传感器数据 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_sensor_screen</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>          buf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">float</span>         env_temp, cpu_temp;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> humidity;</span><br><span class="line">    <span class="type">char</span>          ip[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;sensor_data.lock);</span><br><span class="line">    env_temp = sensor_data.env_temp;</span><br><span class="line">    humidity = sensor_data.humidity;</span><br><span class="line">    cpu_temp = sensor_data.cpu_temp;</span><br><span class="line">    <span class="built_in">strncpy</span>(ip, sensor_data.ip_addr, <span class="keyword">sizeof</span>(ip));</span><br><span class="line">    pthread_mutex_unlock(&amp;sensor_data.lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// oled_clear(&amp;disp);</span></span><br><span class="line">    disp.font = font2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;TEMP:%.1fC&quot;</span>, env_temp);</span><br><span class="line">    oled_putstrto(&amp;disp, <span class="number">0</span>, <span class="number">29</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;RH:%d%%&quot;</span>, humidity);</span><br><span class="line">    oled_putstrto(&amp;disp, <span class="number">74</span>, <span class="number">29</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;CPU:%.1fC&quot;</span>, cpu_temp);</span><br><span class="line">    oled_putstrto(&amp;disp, <span class="number">0</span>, <span class="number">43</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;IP:%s&quot;</span>, ip);</span><br><span class="line">    oled_putstrto(&amp;disp, <span class="number">0</span>, <span class="number">57</span>, buf);</span><br><span class="line"></span><br><span class="line">    oled_send_buffer(&amp;disp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 看门狗线程 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">watchdog_thread</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(WATCHDOG_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        <span class="type">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;sensor_data.lock);</span><br><span class="line">        <span class="type">time_t</span> last = sensor_data.last_update;</span><br><span class="line">        pthread_mutex_unlock(&amp;sensor_data.lock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (now - last &gt; WATCHDOG_TIMEOUT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;WATCH DOG TIMEOUT\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 可重新启动该程序...</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数据采集线程 */</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">sensor_thread</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;sensor_data.lock);</span><br><span class="line">        sensor_data.last_update = now; <span class="comment">// 喂狗</span></span><br><span class="line">        pthread_mutex_unlock(&amp;sensor_data.lock);</span><br><span class="line"></span><br><span class="line">        update_time_date();</span><br><span class="line">        read_cpu_temp();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每2秒更新一次数据</span></span><br><span class="line">        <span class="keyword">if</span> (now % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            read_dht11();</span><br><span class="line">            read_ip_address();</span><br><span class="line">        &#125;</span><br><span class="line">        usleep(<span class="number">100000</span>); <span class="comment">// 100ms</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数个数判断，判断是否有指定IIC通道</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;用法: %s &lt;I2C设备&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 硬件初始化</span></span><br><span class="line">    <span class="keyword">if</span> (init_gpio() != <span class="number">0</span> || init_oled(argv[<span class="number">1</span>]) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据结构</span></span><br><span class="line">    pthread_mutex_init(&amp;sensor_data.lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">memset</span>(sensor_data.temp_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(sensor_data.temp_buffer));</span><br><span class="line">    <span class="built_in">memset</span>(sensor_data.humi_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(sensor_data.humi_buffer));</span><br><span class="line">    sensor_data.filter_index = <span class="number">0</span>;</span><br><span class="line">    sensor_data.last_update  = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    <span class="type">pthread_t</span> tid[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;tid[<span class="number">0</span>], <span class="literal">NULL</span>, sensor_thread, <span class="literal">NULL</span>) != <span class="number">0</span> || pthread_create(&amp;tid[<span class="number">1</span>], <span class="literal">NULL</span>, watchdog_thread, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Thread creation failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分两个函数，方便做分页显示</span></span><br><span class="line">        show_time_screen();</span><br><span class="line">        show_sensor_screen();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;sensor_data.lock);</span><br><span class="line">    oled_clear(&amp;disp);</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：<code>gcc main.c -o sensor_app -lwiringPi -lpthread</code></p>
<p>执行：<code>sudo ./sensor_app /dev/i2c-3</code></p>
<p>使用了线程，因为不用线程的话直接运行占用内存与CPU比较大，改成这样好多了。由于对Linux编程并不是很熟，暂时只能先这样用，之后再慢慢研究研究。</p>
<ul>
<li>开机自启</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/my_main.service</span><br></pre></td></tr></table></figure>

<p>填入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Run dht11 and oled</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">Restart=always</span><br><span class="line">RestartSec=3</span><br><span class="line">ExecStart=/home/orangepi/code/main /dev/i2c-3</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<ul>
<li>启用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重载</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自启</span></span><br><span class="line">sudo systemctl enable my_main.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">sudo systemctl start my_main.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行状态</span></span><br><span class="line">sudo systemctl status my_main.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有已启动的服务</span></span><br><span class="line">sudo systemctl list-units --type=service</span><br></pre></td></tr></table></figure>

<ul>
<li>停用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止</span></span><br><span class="line">sudo systemctl stop my_main.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">禁止开机自启</span></span><br><span class="line">sudo systemctl disable my_main.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除</span></span><br><span class="line">sudo rm /etc/systemd/system/my_main.service</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重载</span></span><br><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<p>还可以加一下定时自启，以防程序触发看门狗退出</p>
<ul>
<li>创建脚本</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim start_app.sh</span><br></pre></td></tr></table></figure>

<p>填入如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设定要检查的进程名</span>  </span><br><span class="line">PROCESS_NAME=&quot;sensor_app&quot;  </span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用pgrep检查进程是否存在</span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果pgrep返回了进程ID（即$?为0），则进程正在运行</span>  </span><br><span class="line">if pgrep -x &quot;$PROCESS_NAME&quot; &gt; /dev/null  </span><br><span class="line">then  </span><br><span class="line">    echo &quot;$PROCESS_NAME is already running.&quot;  </span><br><span class="line">else  </span><br><span class="line">    # 如果进程未运行，则启动</span><br><span class="line">    echo &quot;Starting $PROCESS_NAME...&quot;  </span><br><span class="line">    sudo systemctl start my_main.service  </span><br><span class="line">    # 检查是否成功启动</span><br><span class="line">    sleep 2 # 等待几秒以确保程序有时间启动  </span><br><span class="line">    if pgrep -x &quot;$PROCESS_NAME&quot; &gt; /dev/null  </span><br><span class="line">    then  </span><br><span class="line">        echo &quot;$PROCESS_NAME started successfully.&quot;  </span><br><span class="line">    else  </span><br><span class="line">        echo &quot;Failed to start $PROCESS_NAME.&quot;  </span><br><span class="line">    fi  </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>赋予可执行权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x start_app.sh</span><br></pre></td></tr></table></figure>

<p>定时执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">30min执行一次上面的脚本</span></span><br><span class="line">*/30 * * * * /home/orangepi/code/start_app.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OrangePi</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>单片机while循环一次时间是多少</title>
    <url>/archives/3a69b252.html</url>
    <content><![CDATA[<h1 id="单片机while-t–-延时时间怎样获取"><a href="#单片机while-t–-延时时间怎样获取" class="headerlink" title="单片机while(t–)延时时间怎样获取"></a>单片机while(t–)延时时间怎样获取</h1><p>先打开keil，</p>
<p>找到 <code>魔法棒 -&gt; Debug -&gt; Use Simulator</code>，将该选项选上，</p>
<p>然后进 <code>Debug</code> 模式</p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">My_Delay</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        My_Delay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在左侧栏选择 <code>Register</code> 有个 <code>Sec</code> 可计程序运行时间（单位为秒）</p>
<p>可精确到 <code>us</code> 级</p>
<p>单步运行，然后算出时间差值即可知道 <code>while</code> 的延时时间</p>
]]></content>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式之红外通信</title>
    <url>/archives/bbd81c5a.html</url>
    <content><![CDATA[<h2 id="红外通信原理"><a href="#红外通信原理" class="headerlink" title="红外通信原理"></a>红外通信原理</h2><h4 id="发送过程"><a href="#发送过程" class="headerlink" title="发送过程"></a>发送过程</h4><p><strong>数据 -&gt; 编码 -&gt; 调制 -&gt; 发送电路</strong></p>
<ol>
<li><p>数据：假设发送的数据为 0XA5，二进制为：10100101 </p>
</li>
<li><p>编码：用脉冲宽度编码（Pulse Width Encoding）来表示二进制数据。每个数据位由一系列的脉冲组成，逻辑0和逻辑1分别由不同的脉冲宽度表示。现假设如下：</p>
</li>
</ol>
<p>​            <strong>逻辑0为：0.5ms高 + 0.5ms低；</strong>            <strong>逻辑1为：1ms高 + 0.5ms低；</strong></p>
<ol start="3">
<li>调制：就是把编码数据放到一定频率的载波上面，即使用数据调制载波，形成一串脉冲信号</li>
<li>发送电路：即：红外灯珠对脉冲信号的发送 + 脉冲信号的放大</li>
</ol>
<h4 id="接收过程"><a href="#接收过程" class="headerlink" title="接收过程"></a>接收过程</h4><p><strong>接收电路 -&gt; 解调 -&gt; 解码 -&gt; 数据</strong></p>
<ol>
<li>接收电路：接收发过来的红外信号</li>
<li>解调：当红外接收管接收到调制信号时，输出高电平，否则输出为低电平</li>
<li>解码：解调后将得到的一系列脉冲变为二进制</li>
<li>数据：解码后即可得到发来的数据，即 0XA5 （二进制为：10100101）</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>红外通信的优点：抗电磁干扰、成本低</strong></p>
<p><strong>红外通信的缺点：传输效率低，易受到环境光干扰导致传输误码</strong></p>
<h2 id="载波"><a href="#载波" class="headerlink" title="载波"></a>载波</h2><p>红外通信一般为 <code>38K</code> 载波，“载波” 简单来讲就是一段周期性的、<strong>不断震荡</strong>的波；</p>
<p><em>注：特别注意的是，对于一些非信号专业的新手来讲，虽然眼睛看到了该条件，但并没有进行思考，只当作“公理”给记住，这时在使用时往往会忽略掉。与福尔摩斯说过的话有异曲同工之处：“你只是用眼睛看，并不是在观察”，现在是：“你只是眼睛看到了，却没有在思考。”</em></p>
<p>我们可通过调制将信息加载到载波上，这样信息就会随着波的传播而发射出去了；波发出去后会受到外界环境光的干扰，这就可能会导致信息的丢失或篡改；理论上来讲：传播距离越远，信息丢失的概率越大。</p>
<h2 id="38K频率"><a href="#38K频率" class="headerlink" title="38K频率"></a>38K频率</h2><p>上面提到载波上的信息可能会丢失，那有没有什么预防措施呢？</p>
<p>这就要说到用 <code>38K</code> 载波的原因了：主要是为了<strong>提高抗干扰能力</strong>，尽量避免因环境光干扰导致的信息丢失或篡改；</p>
<p>另外的原因（来自百度）：</p>
<p>这一频率的选择与常用的 <code>455kHz</code> 晶振密切相关。‌在发射端，‌通过对晶振进行整数分频，‌通常取分频系数为12，‌从而得到 <code>38kHz</code> 的载波频率。‌这种分频方式不仅技术上可行，‌而且经济实用，‌因为它利用了现有的成熟技术和组件，‌避免了开发高精度晶振的成本和复杂性。‌</p>
<p>此外，‌<code>38kHz</code> 的载波频率还具有其特定的优势。‌在红外通信中，‌使用 <code>38kHz</code> 的载波可以实现较高的通信质量和较远的通信距离，‌同时保持较低的功耗和成本。‌这种频率的选择也符合红外通信的基本需求，‌即在保证通信效果的同时，‌尽可能地降低系统成本和功耗。‌</p>
<p><strong>值得注意的是：</strong></p>
<p><code>38K</code> 载波意味着每秒有38000个周期，单个周期的时间为1/38000S。‌这个时间长度代表了<strong>一个完整脉冲</strong>的时间，‌包括高电平和低电平的总时间。‌</p>
<p>但是我们红外通信需要的是高低电平均为1/38000S，因此我们定时器应配置为 <code>76K</code> ，这样每次进中断的时间就是1/38000S，那么产生的高、低电平就是1/38000S了。</p>
<p>OK，了解基本原理后就有大概的框架了：</p>
<ol>
<li>首先要有个波形发生器，用来产生 <code>38K</code> 载波</li>
<li>制定自己的通信协议（也可以使用现有的协议，如： NEC协议）</li>
<li>代码实现</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>红外通信</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>红外通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu服务器部署FRP内网穿透</title>
    <url>/archives/2bb50ac9.html</url>
    <content><![CDATA[<h2 id="下载FRP"><a href="#下载FRP" class="headerlink" title="下载FRP"></a>下载FRP</h2><p><a href="https://github.com/fatedier/frp/releases">FRP - Github下载地址</a></p>
<p>选择合适自己电脑及服务器的架构，然后下载解压即可，我这里用0.44.0版本</p>
<h2 id="上传至服务器并进行配置"><a href="#上传至服务器并进行配置" class="headerlink" title="上传至服务器并进行配置"></a>上传至服务器并进行配置</h2><p>赋予<code>frps</code>可执行权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x frps</span><br></pre></td></tr></table></figure>



<p>我的服务器端 frps.ini 配置如下，可参考一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_addr = 	# 你服务器的内网IP</span><br><span class="line">bind_port = 7000</span><br><span class="line">bind_udp_port = 7000</span><br><span class="line">kcp_bind_port = 7000</span><br><span class="line">vhost_https_port = 7001</span><br><span class="line"></span><br><span class="line"># 仪表盘的相关设置</span><br><span class="line">dashboard_addr = 	# 你服务器的内网IP</span><br><span class="line">dashboard_port = 7500</span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = admin</span><br><span class="line"></span><br><span class="line"># 是否记录日志</span><br><span class="line">log_file = ./frps.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br><span class="line"></span><br><span class="line">authentication_timeout = 1000</span><br><span class="line">token=long123456</span><br><span class="line">allow_ports = 3000-10000</span><br><span class="line">max_pool_count = 50</span><br><span class="line">max_ports_per_client = 5</span><br></pre></td></tr></table></figure>



<p>客户端 frpc.ini 配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 	# 你服务器的公网IP</span><br><span class="line">server_port = 7000</span><br><span class="line">authentication_method = token</span><br><span class="line">token = 	# 自己设置个密码</span><br><span class="line"></span><br><span class="line">[Cloudreve]	# 这是我在自己电脑上开的一个服务</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 5212 # 本地服务的端口</span><br><span class="line">remote_port = 6000 # 设置 服务器IP+端口号 来访问时使用的端口号</span><br><span class="line"></span><br><span class="line">[Alist] # 具体设置同上，之后要加服务就可以参照这个配置往后加</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 5244</span><br><span class="line">remote_port = 7000</span><br></pre></td></tr></table></figure>



<p><strong>切记，配置完端口，要前往安全组开放你所设置的端口号！！</strong></p>
<h2 id="启动FRP服务"><a href="#启动FRP服务" class="headerlink" title="启动FRP服务"></a>启动FRP服务</h2><p>启用服务器端服务，一行指令就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure>



<p>启用客户端服务，我使用了 .bat 命令，比较方便，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">if &quot;%1&quot; == &quot;h&quot; goto begin</span><br><span class="line">mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~nx0&quot;&quot; h&quot;,0)(window.close)&amp;&amp;exit</span><br><span class="line">:begin</span><br><span class="line">REM</span><br><span class="line">cd D:\frp_0.44.0 ::frp.exe所在路径</span><br><span class="line">frpc -c frpc.ini</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>



<h2 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h2><ul>
<li>创建 systemd 服务文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/systemd/system/frps.service</span><br></pre></td></tr></table></figure>

<ul>
<li>添加配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=frps Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/home/www/frp/frps -c /home/www/frp/frps.ini</span><br><span class="line">Restart=always</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>上面<code>ExecStart=/home/www/frp/frps -c /home/www/frp/frps.ini</code>是<code>frps</code>目录</p>
<ul>
<li>重新加载 systemd 配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<ul>
<li>设置开机自启</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable frps</span><br><span class="line">sudo systemctl start frps</span><br></pre></td></tr></table></figure>

<ul>
<li>查看是否开启</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status frps</span><br></pre></td></tr></table></figure>

<p>这里的<code>frps</code>是指上面创建的<code>systemd</code>服务文件的名字，我用的是<code>frps.service</code>，所以就用<code>frps</code></p>
<h2 id="结束开机自启"><a href="#结束开机自启" class="headerlink" title="结束开机自启"></a>结束开机自启</h2><p>你如果需要关闭开机自启，可执行以下操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop frps</span><br><span class="line">sudo systemctl disable frps</span><br><span class="line">sudo systemctl enable frps</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FRP</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>FRP</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下不使用各类面板建站</title>
    <url>/archives/fe15a55f.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>恰逢国庆中秋双节放假，闲来无事，想着搞点什么玩玩；思来想去，还是写个博客吧！</p>
<p>由于之前建站都是使用的宝塔或者直接docker部署，感觉对于Linux指令的掌握没什么进步；就想着不使用面板来建个站，虽然不便管理，但学习嘛，不怕困难。</p>
<span id="more"></span>

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li>服务器及域名</li>
<li>爱折腾的心</li>
</ul>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="1-Apache"><a href="#1-Apache" class="headerlink" title="1. Apache"></a>1. Apache</h3><p><strong>更新源</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p><strong>安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install apache2</span><br></pre></td></tr></table></figure>

<p><strong>查看apache运行状态</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl status apache2</span><br></pre></td></tr></table></figure>

<p><strong>开机自启Apache</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable apache2</span><br></pre></td></tr></table></figure>

<p><strong>修改配置文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/apache2/apache2.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Directory /var/www&gt; # 这里是自己的网站目录</span><br><span class="line">	Options Indexes FollowSymLinks</span><br><span class="line">	AllowOverride None</span><br><span class="line">	Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure>

<p><strong>修改端口文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/apache2/ports.conf</span><br></pre></td></tr></table></figure>

<p>其中 <code>Listen 80</code> 改为你想要的端口，如8080等</p>
<p><strong>绑定文件夹位置对应端口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/apache2/sites-available/000-default.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:8080&gt; # 这里是你上面设置的端口号</span><br><span class="line">	ServerAdmin webmaster@localhost</span><br><span class="line">	DocumentRoot /var/www # 这里是你上面设置的目录</span><br><span class="line">	ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class="line">	CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>

<p><strong>修改网站文件夹权限 – 给读写权限</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chmod 775 -R /var/www</span><br></pre></td></tr></table></figure>

<p><strong>重启Apache</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart apache2</span><br></pre></td></tr></table></figure>

<p><strong>启动Apache</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start apache2</span><br></pre></td></tr></table></figure>

<p><strong>停止Apache</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart apache2</span><br></pre></td></tr></table></figure>

<p><em>注：安装完毕apache并运行后如果访问不了网站，可能是因为端口未开放，开放端口即可；apache监听了80（http）与443（https）端口，需要开放这两个，此外如果你上面更改了端口号，也需将你更改过的端口开放；具体方法见下</em></p>
<h3 id="2-端口"><a href="#2-端口" class="headerlink" title="2. 端口"></a>2. 端口</h3><p><strong>打开防火墙端口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 8080/tcp</span><br></pre></td></tr></table></figure>

<p>即：sudo ufw allow [端口号]/[协议]</p>
<p><strong>批量开放端口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 20:21/tcp</span><br></pre></td></tr></table></figure>

<p><strong>关闭端口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw delete allow 8080</span><br></pre></td></tr></table></figure>

<p><strong>查看开放端口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw status</span><br></pre></td></tr></table></figure>

<p><strong>关闭/启用所有防火墙</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw disable/enable</span><br></pre></td></tr></table></figure>

<p>此外，还需要到你的主机提供平台，找到”安全组”，将端口放开，否则也访问不了网站</p>
<h3 id="3-PHP"><a href="#3-PHP" class="headerlink" title="3. PHP"></a>3. PHP</h3><p><strong>安装php8.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php8.0</span><br></pre></td></tr></table></figure>

<p><strong>若报如下错误</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E: Unable to locate package php8.0</span><br><span class="line">E: Couldn&#x27;t find any package by glob &#x27;php8.0&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>可依次执行以下命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install php8.0</span><br></pre></td></tr></table></figure>

<p><strong>检查是否安装成功</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">php -v</span><br></pre></td></tr></table></figure>

<p><strong>安装php拓展</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install php8.0-mysqli </span><br></pre></td></tr></table></figure>

<p>即：sudo apt-get install php8.0-(拓展名)</p>
<p><strong>安装完成后在Apache中启用php8.0</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a2enmod php8.0</span><br></pre></td></tr></table></figure>

<h3 id="4-待续。。。"><a href="#4-待续。。。" class="headerlink" title="4. 待续。。。"></a>4. 待续。。。</h3>]]></content>
      <categories>
        <category>建站</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>建站</tag>
      </tags>
  </entry>
  <entry>
    <title>精确搜索之Google搜索语法大全</title>
    <url>/archives/c54b318a.html</url>
    <content><![CDATA[<h2 id="Google谷歌搜索语法大全"><a href="#Google谷歌搜索语法大全" class="headerlink" title="Google谷歌搜索语法大全"></a>Google谷歌搜索语法大全</h2><span id="more"></span>

<table>
<thead>
<tr>
<th align="center"><strong>算</strong> <strong>符</strong></th>
<th align="center"><strong>含</strong>  <strong>义</strong></th>
<th align="center"><strong>应用举例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">AND/空格</td>
<td align="center">所连接的关键词之间是“与”的关系</td>
<td align="center">云计算 分布式计算</td>
</tr>
<tr>
<td align="center">OR/|</td>
<td align="center">所连接的关键词之间是“或”的关系</td>
<td align="center">图片 | 风景</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">所连接的关键词之间是“非”的关系</td>
<td align="center">神雕侠侣 - 游戏</td>
</tr>
<tr>
<td align="center">（）</td>
<td align="center">在检索式中括号里的运算将优先进行</td>
<td align="center">电子商务 AND (云计算 - 分布式计算)</td>
</tr>
<tr>
<td align="center">“ “</td>
<td align="center">“ “英文双引号中的内容作为一个整体被搜索，精确匹配搜索</td>
<td align="center">“智能天线”</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">通配符——星号(*)，代表完整的字词：A * B与A * * B是有区别的</td>
<td align="center">Flower * pots 与Flower * * pots</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">强制搜索一般会被自动忽略的搜索关键词，如：who、the、of、am</td>
<td align="center">+ B</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">同义符——在搜索词前使用，表示会和同时搜索相近词义的词；注：示例中会同搜元素Si</td>
<td align="center">~ silicon</td>
</tr>
<tr>
<td align="center">..</td>
<td align="center">搜索数字范围限定</td>
<td align="center">手机 价格2000..5000</td>
</tr>
<tr>
<td align="center">filetype:</td>
<td align="center">把搜索范围限定在特定文件类型中；.pdf/.doc/.docx/.ppt/.pptx/.xls/.xlsx/.rtf/.txt/.swf/.ps</td>
<td align="center">霍金 黑洞filetype: .pdf</td>
</tr>
<tr>
<td align="center">site:</td>
<td align="center">把搜索范围限定在特定站点、某一站点特定频道、特定域名后缀中</td>
<td align="center">科技 site: news.163.com</td>
</tr>
<tr>
<td align="center">inurl:</td>
<td align="center">把搜索范围限定在url链接中</td>
<td align="center">inurl: jiqiao  photoshop</td>
</tr>
<tr>
<td align="center">allinurl:</td>
<td align="center">把搜索范围限定在url链接中，只不过其后所有关键词均要在url链接中出现</td>
<td align="center">allinurl: jiqiao  photoshop</td>
</tr>
<tr>
<td align="center">intitle:</td>
<td align="center">把搜索范围限定在网页标题中</td>
<td align="center">商业 intitle: 超级女声</td>
</tr>
<tr>
<td align="center">allintitle:</td>
<td align="center">把搜索范围限定在网页标题中；只不过其后所有关键词均要在网页标题中出现</td>
<td align="center">allintitle: 超级女声 张靓颖</td>
</tr>
<tr>
<td align="center">intext:</td>
<td align="center">把搜索范围限定在网页正文中；忽略超链接文本、URL以及题目等</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">inanchor:</td>
<td align="center">把搜索范围限定在链接锚文本文字中</td>
<td align="center">inanchor: 岳飞</td>
</tr>
<tr>
<td align="center">anchor:</td>
<td align="center">检索某一作者/发明人的论著；<strong>只在Google Scholar中可用</strong></td>
<td align="center">anchor: /作者:</td>
</tr>
<tr>
<td align="center">link:</td>
<td align="center">检索所有链接到某个特定URL网址的网页；只能单独使用</td>
<td align="center">link: 163.com</td>
</tr>
<tr>
<td align="center">cache:</td>
<td align="center">Google网页快照</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">related:</td>
<td align="center">检索与某特定网页类似的网页</td>
<td align="center">related: <a href="http://www.163.com/index.shtml">www.163.com/index.shtml</a></td>
</tr>
<tr>
<td align="center">info:</td>
<td align="center">用来显示与某链接相关的一系列搜索；提供cache、similar-pages、link、related等连接</td>
<td align="center">info: <a href="http://www.sina.com.cn/">www.sina.com.cn</a></td>
</tr>
<tr>
<td align="center">Index  of</td>
<td align="center">可以帮助你寻找网络和FTP目录</td>
<td align="center">index  of mp3</td>
</tr>
<tr>
<td align="center">daterange:</td>
<td align="center">查找在一定的日期或者一定的日期范围内；只关注被Google收录的时间</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">location:</td>
<td align="center">指定地区区域内查询关键词相关的网页</td>
<td align="center">wow  gold location: France</td>
</tr>
<tr>
<td align="center">weather:</td>
<td align="center">查询该地区或城市当前的天气状况</td>
<td align="center">weather: 北京</td>
</tr>
<tr>
<td align="center">stocks:</td>
<td align="center">查询股票信息；一般源于专业财经网站</td>
<td align="center">stocks: 比亚迪</td>
</tr>
<tr>
<td align="center">define:</td>
<td align="center">返回包含查询关键词定义的网面</td>
<td align="center">define: 暗网</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<p><strong>关键词与命令之间有一个空格；命令需用英文输入，包括冒号。</strong></p>
<p><strong>AND、OR、NOT均应大写，而其他算符必须是小写，虽其对检索词完全不区分大小写！</strong></p>
<blockquote>
<h3 id="Google高级搜索"><a href="#Google高级搜索" class="headerlink" title="Google高级搜索"></a>Google高级搜索</h3><p><a href="http://www.google.com.hk/advanced_search">http://www.google.com.hk/advanced_search</a>                                                   </p>
<h3 id="Google网页搜索帮助中心"><a href="#Google网页搜索帮助中心" class="headerlink" title="Google网页搜索帮助中心"></a>Google网页搜索帮助中心</h3><p><a href="https://support.google.com/websearch/?hl=zh-Hans">https://support.google.com/websearch/?hl=zh-Hans</a></p>
<h3 id="谷歌分类目录"><a href="#谷歌分类目录" class="headerlink" title="谷歌分类目录"></a>谷歌分类目录</h3><p><a href="http://directory.google.com/">http://directory.google.com/</a></p>
<p><strong>Google对于检索词中的大小写是完全不做区分的；在Google中，检索词的排序方式对于整个检索式具有重要的影响，它将首先匹配按照检索式给出的次序进行搜索。同时它也将优先匹配检索词相互邻接的网页。GOOGLE支持多达132种语言，包括简体中文和繁体中文，可以设置页面语言和搜索语言，可对汉字繁简体进行转换，可以跨语言搜索。Google搜索结果中可对搜索范围进行限制，如：网页的发布更新时间或一个时间段内，搜索结果的类型选择如图片、视频、书籍、应用程序、新闻。</strong></p>
</blockquote>
<p>PS:之前还有一篇与此文类似，<a href="https://blog.totoroweb.fun/archives/c485373b.html">点我跳转</a></p>
]]></content>
      <categories>
        <category>精确搜索</category>
      </categories>
      <tags>
        <tag>搜索技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu部署其他Docker项目</title>
    <url>/archives/db0817f.html</url>
    <content><![CDATA[<ul>
<li>拉取Alist镜像并部署</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name=&quot;alist&quot; xhofe/alist:latest</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>通过日志获取默认密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs alist</span><br><span class="line">#或者</span><br><span class="line">docker exec -it alist ./alist admin</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">配置文件路径：/opt/alist/data/config.json</span><br><span class="line">---------如何获取密码？--------</span><br><span class="line">先cd到alist所在目录:</span><br><span class="line">cd /opt/alist</span><br><span class="line">随机设置新密码:</span><br><span class="line">./alist admin random</span><br><span class="line">或者手动设置新密码:</span><br><span class="line">./alist admin set NEW_PASSWORD</span><br><span class="line">----------------------------</span><br><span class="line">查看状态：systemctl status alist</span><br><span class="line">启动服务：systemctl start alist</span><br><span class="line">重启服务：systemctl restart alist</span><br><span class="line">停止服务：systemctl stop alist</span><br></pre></td></tr></table></figure>

<p><strong>除了上面的命令外还可以参考Alist官网的安装方式：<a href="https://alist.nn.ci/zh/guide/install/script.html">Alist安装</a></strong></p>
<ul>
<li>拉取文件快递柜镜像并部署</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always -p 12345:12345 -v /opt/FileCodeBox/:/app/data --name filecodebox lanol/filecodebox:latest</span><br></pre></td></tr></table></figure>

<p><em>如果需要修改配置，可以修改/opt/FileCodeBox/目录下的.env文件；里边包含后台地址、后台密码等</em></p>
<ul>
<li>部署Cloudreve</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull cloudreve/cloudreve</span><br><span class="line">#拉取最新Cloudreve镜像</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/cloudreve/uploads</span><br><span class="line">#在本地创建cloudreve数据卷映射目录</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name cloudreve \</span><br><span class="line">-p 4777:80 --restart=always \</span><br><span class="line">-v /data/cloudreve/uploads:/cloudreve/uploads \</span><br><span class="line">cloudreve/cloudreve:latest</span><br><span class="line">#启动cloudreve容器(4777端口，也可更换其他端口)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it cloudreve /bin/sh</span><br><span class="line">#进入cloudreve容器，需要将 conf.ini 文件中的端口设置为80才能正常访问</span><br><span class="line"></span><br><span class="line">vi conf.ini</span><br><span class="line">#修改命令，点击i键开始修改，修改完成点击Esc完成修改，输入:wq保存并退出</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart cloudreve</span><br><span class="line">#重启cloudreve容器</span><br></pre></td></tr></table></figure>

<p>用 <code>ip:端口号 </code>访问，    然后获取初始密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs cloudreve</span><br></pre></td></tr></table></figure>



<ul>
<li>青龙面板docker部署</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#docker安装</span><br><span class="line">sudo curl -sSL get.docker.com | sh</span><br><span class="line"></span><br><span class="line">#启动容器</span><br><span class="line">podman run -dit \</span><br><span class="line">  --network bridge \</span><br><span class="line">  -v $PWD/ql/data:/ql/data \</span><br><span class="line">  -p 5700:5700 \</span><br><span class="line">  --name qinglong \</span><br><span class="line">  --hostname qinglong \</span><br><span class="line">  docker.io/whyour/qinglong:latest</span><br></pre></td></tr></table></figure>



<ul>
<li>qbittorrent</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull  lscr.io/linuxserver/qbittorrent:latest</span><br><span class="line">#拉取镜像</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/qbit  	#创建数据目录</span><br><span class="line">cd /data/qbit/  		#进入qbit目录</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name=qbittorrent \</span><br><span class="line">  -e PUID=1000 \</span><br><span class="line">  -e PGID=1000 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e WEBUI_PORT=8080 \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  -p 6881:6881 \</span><br><span class="line">  -p 6881:6881/udp \</span><br><span class="line">  -v /data/qbit//config:/config \</span><br><span class="line">  -v /data/qbit/downloads:/downloads \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">lscr.io/linuxserver/qbittorrent:latest</span><br><span class="line">#创建qbittorrent容器</span><br></pre></td></tr></table></figure>

<p>默认用户：    User: admin    PassWord: adminadmin</p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/archives/29dc6fe8.html</url>
    <content><![CDATA[<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><ul>
<li>启动容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker start 容器id               # 启动容器</span><br><span class="line">docker restart 容器id             # 重启容器</span><br><span class="line">docker start $(docker ps -a -q)  # 启动所有容器</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><ul>
<li>停止容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stop 容器id                # 停止当前运行的容器</span><br><span class="line">docker kill 容器id                # 强制停止当前容器</span><br><span class="line">docker stop $(docker ps -a -q)	 # 停止所有容器</span><br></pre></td></tr></table></figure>

<h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ul>
<li>查看运行的容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">	-a   		# 查看所有容器的运行记录</span><br><span class="line">	-n=?   		# 显示最近创建的n个容器</span><br><span class="line">	-q   		# 只显示容器的id</span><br></pre></td></tr></table></figure>

<ul>
<li>查看容器运行日志</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs -tf 容器id</span><br><span class="line">docker logs --tail num 容器id   	# num为要显示的日志条数</span><br></pre></td></tr></table></figure>

<ul>
<li>查看所有镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<ul>
<li>获取容器ID</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps | grep &quot;$filename&quot; | awk &#x27;&#123;print $1&#125;&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看容器基本信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect   		#容器id</span><br></pre></td></tr></table></figure>



<ul>
<li>容器命名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker run --name deng_container -i -t ubuntu /bin/bash</span><br><span class="line"># 使用–name 参数，在后面加上你想为容器取的名字</span><br></pre></td></tr></table></figure>

<p><em>PS：取名注意事项：</em></p>
<p><em>1. 名字的字符是有限制的，只能使用a-z,A-Z,0-9，下划线，圆点、横线</em></p>
<p><em>2. 在一些操作容器docker命令中，我们可以使用容器的名字代替容器的id，因为很明显容器的ID比容器的名字更好记，所以，容器的名字和容器的ID一样，不能重复；</em></p>
<ul>
<li>进入容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器id /bin/bash</span><br></pre></td></tr></table></figure>

<ul>
<li>退出容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit   		# 停止容器并退出（后台方式运行则仅退出）</span><br><span class="line">Ctrl+P+Q    # 不停止容器退出</span><br></pre></td></tr></table></figure>

<h3 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h3><ul>
<li>保存镜像</li>
</ul>
<p><em>将我们的镜像 保存为 tar压缩文件，这样方便镜像转移和保存，然后 可以在任何一台安装了docker的服务器上加载这个镜像</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save 镜像名/镜像ID -o 镜像保存在哪个位置与名字</span><br></pre></td></tr></table></figure>

<ul>
<li>加载镜像</li>
</ul>
<p><em>任何装有docker 的地方加载镜像保存文件，使其恢复为一个镜像</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker load -i   		#镜像保存文件位置</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>删除容器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rm -f 容器名/容器ID   			#删除一个容器</span><br><span class="line">docker rm -f 容器名/容器ID 容器名/容器ID   #删除多个容器 空格隔开要删除的容器名或容器ID</span><br><span class="line">docker rm -f $(docker ps -aq)   		#删除全部容器</span><br></pre></td></tr></table></figure>

<ul>
<li>删除所有镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure>

<ul>
<li>删除镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker rmi -f 镜像名/镜像ID</span><br></pre></td></tr></table></figure>

<p>注：要完全删除一个项目，需要先删除其容器，再删除其镜像；</p>
<p>可通过 <code>docker ps -a</code> 来查看容器对应的ID，再用 <code>docker images</code> 查看镜像对应的ID</p>
<hr>
<p><strong>待续…</strong></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu部署Memos</title>
    <url>/archives/2bf03cc2.html</url>
    <content><![CDATA[<h2 id="Ubuntu部署Memos"><a href="#Ubuntu部署Memos" class="headerlink" title="Ubuntu部署Memos"></a>Ubuntu部署Memos</h2><ul>
<li>拉取镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull neosmemo/memos:latest</span><br></pre></td></tr></table></figure>

<ul>
<li>运行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name memos -p 5230:5230 -v ~/.memos/:/var/opt/memos neosmemo/memos:latest</span><br></pre></td></tr></table></figure>

<p>然后我们检查项目是否运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>如下图：说明已经运行。</p>
<img src="https://s2.loli.net/2023/02/28/5BjGSn2fDrdiTo6.jpg" style="zoom:67%;" />

<p>不过，现在我们还不能访问，因为我们的5230端口还没有开放。</p>
<p>回到  控制台 -&gt; 云服务器ECS -&gt; 网络与安全 -&gt; 安全组 -&gt; 管理规则 -&gt; 入方向 -&gt; 手动添加</p>
<p>添加一个如下规则，然后保存即可：</p>
<img src="https://s2.loli.net/2023/02/28/XMINo6dHUTGb3OB.jpg" style="zoom:67%;" />

<p>这样我们就可以在浏览器里通过你的  <code>公网IP:5230</code>  访问Memos了。</p>
<h2 id="登录Memos"><a href="#登录Memos" class="headerlink" title="登录Memos"></a>登录Memos</h2><p>第一次登录Memos，是英文界面，你可以在底部设置语言，然后注册个管理员账号，注册完成就可以登录了；登陆后，界面还是英文，你可以在左侧栏找到 Setting -&gt; Preference -&gt; Language -&gt; 简体中文 来设置中文。</p>
<p>个人觉得，Memos确实好用，自己去发现吧！</p>
<p>至此，教程全部结束；</p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>Docker里可以部署多个应用，只要端口号不冲突就行；然后通过 <code>公网IP:端口号</code> 进行访问就行。</p>
<p>这里推荐几个自己用着不错的docker项目：</p>
<ul>
<li><a href="https://alist.nn.ci/guide/install/docker.html">Alist</a></li>
<li><a href="https://github.com/usememos/memos">Memos</a></li>
<li><a href="https://docs.cloudreve.org/getting-started/install">Cloudreve</a></li>
<li><a href="https://github.com/whyour/qinglong">青龙面版</a></li>
<li><a href="https://github.com/vastsa/FileCodeBox">文件快递柜</a></li>
</ul>
<hr>
<h2 id="2023-03-14更新"><a href="#2023-03-14更新" class="headerlink" title="2023.03.14更新"></a>2023.03.14更新</h2><p>对于memos版本的升级：</p>
<p>先用 <code>docker ps</code> 查看memos的ID，然后用 <code>docker stop 容器ID</code> 来停止容器运行，最后重复上面的安装步骤即可更新：</p>
<ul>
<li>拉取镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull neosmemo/memos:latest</span><br></pre></td></tr></table></figure>

<ul>
<li>运行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name memos -p 5230:5230 -v ~/.memos/:/var/opt/memos neosmemo/memos:latest</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：升级前要先备份数据，数据存放路径为 <code>/root/.memos/memos_prod.db</code> ，将这个db文件复制一份到别的目录，或者下载下来都行；这里推荐使用 FTP 工具，直接和在电脑上操作文件一样，就不用敲命令了。</strong></p>
</blockquote>
<p>另：你可以通过查看其日志来查看版本号，看是否升级成功！</p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Ubuntu</tag>
        <tag>Memos</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装Docker</title>
    <url>/archives/bc681fc7.html</url>
    <content><![CDATA[<h1 id="Ubuntu安装Docker"><a href="#Ubuntu安装Docker" class="headerlink" title="Ubuntu安装Docker"></a>Ubuntu安装Docker</h1><ul>
<li>先更源，保证是最新</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<ul>
<li>先卸载旧版本Docker</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure>

<ul>
<li>安装Docker依赖（Docker在Ubuntu上依赖一些软件包）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure>

<ul>
<li>添加Docker官方密匙</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<ul>
<li>添加Docker软件源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 添加Docker软件源 报错 <code>sudo: add-apt-repository: command not found</code>，可执行下面两条指令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-software-properties</span><br><span class="line">sudo apt-get install software-properties-common</span><br></pre></td></tr></table></figure>

<p>然后再次执行<strong>添加Docker软件源</strong>指令即可</p>
<ul>
<li>安装Docker</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<ul>
<li>验证是否安装成功</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p>出现以下即成功：</p>
<img src="https://s2.loli.net/2023/09/30/9gZMGPLCAWj87UE.jpg" style="zoom:50%;" />

<ul>
<li>启动docker</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<ul>
<li>加入开机自启</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>最近用到的CMD指令</title>
    <url>/archives/1ff8041c.html</url>
    <content><![CDATA[<h3 id="1-查看并导出目录文件夹名称"><a href="#1-查看并导出目录文件夹名称" class="headerlink" title="1. 查看并导出目录文件夹名称"></a>1. 查看并导出目录文件夹名称</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tree</span>&gt;list.txt		//查看文件夹并导出为list.txt文件</span><br><span class="line"><span class="built_in">tree</span> /f &gt;list.txt		//查看文件夹及里面的文件并导出为list.txt文件</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><strong>解释：</strong></p>
<ul>
<li>只查看不导出，只用 <code>tree</code> 就行</li>
<li><code>list.txt</code> 可以自己更改（<code>list</code> 为文件名，<code>txt</code> 为后缀；文件名可以自定义，后缀可以为：<code>txt、md、xls</code> 等）</li>
<li>加上 <code>/f</code> 为显示文件夹下的文件，不加的话就只显示文件夹</li>
</ul>
<h3 id="2-批量更改文件名及后缀"><a href="#2-批量更改文件名及后缀" class="headerlink" title="2. 批量更改文件名及后缀"></a>2. 批量更改文件名及后缀</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ren</span> *.txt *.<span class="built_in">md</span>		//改后缀名</span><br><span class="line"><span class="built_in">ren</span> 旧文件名.txt 新文件名.txt		//改文件名</span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<ul>
<li><code>ren</code> 为更改后缀的命令</li>
<li><code>*.txt</code> 为更改前的后缀</li>
<li><code>*.md </code> 为你要更改的后缀</li>
</ul>
<p>如果你要更改所有文件，不只是<code>txt</code> 文件；那么可以用 <code>ren *. *.md</code> 命令！</p>
<p>ps: 上面的 <code>*</code> 为通配符，通配符还有一个 <code>? </code>; 具体作用为：<code>? </code>代表匹配一个字符， <code>*</code> 代表匹配多个字符；</p>
<p>其应用也很广，可以用来搜索你不记得具体名称的文件夹：</p>
<blockquote>
<ol>
<li><p>比如你记得你磁盘有一个文件，它的文件名的第一个字符不记得了，只记得第二个是a，第三个不记得了，第四个是1，后面的又不记得了，而且是一个 <code>css</code> 文件，怎么搜索呢？</p>
<p>答：<code>?a?1*.css </code> 这样就能找到了。</p>
</li>
<li><p>还有一个文件，文件名的前三个字符不记得了，后面是hello，是一个 <code>css</code> 文件，怎么找呢？</p>
<p>答：<code>???hello.css</code></p>
</li>
<li><p>如果一个文件是以 <code>module</code> 结尾的该怎么搜索？</p>
<p>答：<code>dir *module </code></p>
</li>
<li><p>如果一个文件是以 <code>module</code> 开头的怎么搜索？</p>
<p>答：<code>dir module*</code></p>
</li>
</ol>
</blockquote>
<h3 id="3-查看WiFi密码"><a href="#3-查看WiFi密码" class="headerlink" title="3. 查看WiFi密码"></a>3. 查看WiFi密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&#x27;netsh wlan show profiles&#x27;) do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear</span><br></pre></td></tr></table></figure>

<p><strong>使用：</strong>这个代码可以查看你的笔记本电脑已经连接过的<code>wifi</code>密码，主要用于连接上但密码忘记的情况！</p>
<h3 id="4-修复电脑桌面白图标"><a href="#4-修复电脑桌面白图标" class="headerlink" title="4. 修复电脑桌面白图标"></a>4. 修复电脑桌面白图标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@duecho off</span><br><span class="line">taskkill /f /im explorer.exe</span><br><span class="line">CD /d %userprofile%\AppData\Local</span><br><span class="line">DEL IconCache.db /a</span><br><span class="line">start explorer.exe</span><br><span class="line">cho 执行完成</span><br></pre></td></tr></table></figure>

<p><strong>使用：</strong>复制上面的代码，在桌面新建一个文本文档，将其粘贴进去，再将后缀改为<code>.bat</code> ，双击运行，然后刷新一下桌面即可。</p>
<h3 id="5-图片隐写"><a href="#5-图片隐写" class="headerlink" title="5. 图片隐写"></a>5. 图片隐写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">copy /b test.jpg + document.rar yincang.jpg</span><br></pre></td></tr></table></figure>

<p><strong>使用：</strong>将要隐藏的文件和图片放在同一个文件夹中；打开命令提示符窗口并输入以上代码（其中<code>test.jpg</code>为图片名称，<code>doucument.rar</code>为压缩包名称，<code>yincang.jpg</code>为输出的含有文件的图片名称）</p>
<p><strong>说明：</strong>如果要找回文件，将输出的图片后缀改为<code>.rar</code>再解压即可！</p>
]]></content>
      <categories>
        <category>CMD</category>
      </categories>
      <tags>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>Github+PicGo图床搭建</title>
    <url>/archives/febc4fee.html</url>
    <content><![CDATA[<h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><p>首先需要准备：</p>
<ul>
<li>一个<code>GitHub</code>账号</li>
<li>（没有的话先注册一个）</li>
<li>下载<code>PicGo</code>软件并安装</li>
<li>（软件<code>GitHub</code>地址：<a href="https://github.com/Molunerfinn/PicGo/releases%EF%BC%89">https://github.com/Molunerfinn/PicGo/releases）</a><span id="more"></span></li>
</ul>
<h3 id="创建仓库："><a href="#创建仓库：" class="headerlink" title="创建仓库："></a>创建仓库：</h3><p>打开<code>GitHub</code>，点击右上角的<code>“＋”</code>号，选择第一个<code>“New repository”</code>创建一个存放图片的仓库；</p>
<img src="https://s2.loli.net/2022/07/10/VE75bD61GXOge2n.jpg" style="zoom: 80%;" />

<p>仓库名称可以起个<code>“Image”</code>，描述的话随便就行，然后一定要选<code> “Public”</code> 不要选 <code>“Private” </code>下边随便勾一下<code>“Add a README file”</code>就行！最后点击 <code>“Create repository” </code>来创建，具体如下图：</p>
<img src="https://s2.loli.net/2022/07/10/hWmGrZ3es5Ry6d1.jpg" style="zoom: 50%;" />

<h3 id="获取Token："><a href="#获取Token：" class="headerlink" title="获取Token："></a>获取Token：</h3><p>回到<code>GitHub</code>主页，点击右上角头像，在下拉菜单中找到 <code>“Setting”</code>；然后翻到最下边，点击 <code>“Developer setting”</code>，</p>
<img src="https://s2.loli.net/2022/07/10/fhEZRywAuSnGc1M.jpg" style="zoom: 50%;" />

<p>再点击最下边的<code> “Personal access tokens”</code> ，然后新建一个 <code>token </code>就行，如下：</p>
<img src="https://s2.loli.net/2022/07/10/coxK8Pjd5OF4rqX.jpg" style="zoom: 50%;" />

<img src="https://s2.loli.net/2022/07/10/QmsSeE2Y7fAaVPb.jpg" style="zoom:50%;" />

<p><code>&quot;Note&quot;</code> 可以随便填一个，时间的话自己选个天数就行（这个天数是 <code>token</code> 过期的时间），我这里就选个90天吧！最重要的是上面图中我圈起来的一定要打上勾！一定要！然后划到最下边点击创建就行了！然后你就会看到你的 <code>Token </code>，值得注意的是：<strong>这个<code>token</code>只会出现一次，一定要记在什么地方备用</strong>，要是真么忘记的话，可以再新建一个！</p>
<h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置<code>PicGo</code></h3><p>打开<code>picgo</code>软件，找到“图床设置”，点击“<code>Github</code>图床”，按如下配置：</p>
<img src="https://s2.loli.net/2022/07/10/xEsorp9iFnIAYPq.jpg" style="zoom:50%;" />

<p>解释一下：</p>
<ul>
<li>设定仓库名：这里填的是 你<code>GitHub</code>的用户名 + 你刚才建的仓库名</li>
<li>设定分支名：<strong>一定要填<code> “main”</code></strong> 不要填<code>“master”</code>否则配置不生效！！</li>
<li>设定<code>Token</code>：这里填你刚才创建的 <code>token</code> 即可</li>
<li>指定存储路径：按图上填就行</li>
<li>设定自定义域名：前面的都是一样的，后面两项为你的用户名和仓库名；具体为：<code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code></li>
</ul>
<p>点击确定，就可以了，现在你可以上传一张图片测试一下！</p>
<p>如果不成功的话，就去问百度吧！</p>
<hr>
<p>哦，对了，最后附上 <code>PicGo</code>的官方文档吧：</p>
<p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/#%E5%BA%94%E7%94%A8%E6%A6%82%E8%BF%B0">官方指南</a></p>
<p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A">用户配置</a></p>
<p>注意：设定分支名：<strong>一定要填<code> “main”</code></strong> 不要填 <code>“master” </code>否则配置不生效！！这一点不要按照官方文档的来！</p>
<p>OK，完事！</p>
]]></content>
      <categories>
        <category>Github</category>
        <category>PicGo</category>
        <category>图床</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>PicGo</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>Ngrok内网穿透</title>
    <url>/archives/bd50b816.html</url>
    <content><![CDATA[<p>内网穿透，即 NAT 穿透，进行 NAT 穿透是为了使具有某一个特定源 IP 地址和源端口号的数据包不被 NAT 设备屏蔽而正确路由到内网主机。<span id="more"></span></p>
<p>最开始了解内网穿透是为了将自己写的项目能够让别人看见，但当时又不了解服务器等东西，就上网搜方法；偶然看到说内网穿透可以，所以就找了好多教程；最终就选了以下这种方法！</p>
<hr>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>安装好jdk并配置环境变量、下载Tomcat并配置环境变量、注册一个Ngrok账号、一台电脑</p>
<h3 id="配置jdk与Tomcat"><a href="#配置jdk与Tomcat" class="headerlink" title="配置jdk与Tomcat"></a>配置jdk与Tomcat</h3><p>这个就不详写了，上网一搜一大堆！（注意Tomcat要与jdk的版本号对应，具体看官网对应关系：<a href="http://tomcat.apache.org/whichversion.html">Apache Tomcat® - Which Version Do I Want?</a>）</p>
<h3 id="注册并登录Ngrok以及开通隧道"><a href="#注册并登录Ngrok以及开通隧道" class="headerlink" title="注册并登录Ngrok以及开通隧道"></a>注册并登录Ngrok以及开通隧道</h3><p>Ngrok官网：<a href="https://www.ngrok.cc/">Sunny-Ngrok内网穿透服务</a></p>
<p>因为Ngrok是有免费线路的，所以完全可以白嫖。😁 一般不会失效，如果失效，再次开通就行。</p>
<p>登录进入后选择“隧道管理” —&gt; “开通隧道” —&gt; 向下滑，找到最后一个价格为0元的，购买就行；</p>
<p><strong>协议</strong>选<code>http/https</code>均可，<strong>隧道名称</strong>随便起，<strong>前置域名</strong>随便起（尽量短，好记；用英文、数字都行），<strong>本地端口</strong>默认就行，下面两个不用填，点击<strong>确定添加</strong>就可以了。</p>
<p>开通成功后可以在<strong>隧道管理</strong>查看自己的隧道了。然后下载客户端，<a href="https://www.ngrok.cc/download.html">Sunny-Ngrok内网转发客户端</a>，选择自己电脑的版本即可！</p>
<h3 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h3><p>下载后解压双击运行<code>Sunny-Ngrok启动工具.bat</code>，它会提示你要id,这时回到网页<strong>隧道管理</strong>找到你的<strong>隧道id</strong>粘贴进去，然后回车就行。</p>
<p>这时如果你通过你的网址进行访问会提示你隧道不可用；这是因为你没有运行Tomcat，你cmd运行Tomcat后，再刷新就能看到Tomcat的页面了，如图：</p>
<p><img src="https://s2.loli.net/2022/07/10/TOGBXVCNj68AmiZ.jpg"></p>
<p>出现这个页面就恭喜你了，你已经成功了！</p>
<hr>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这时你的内网穿透已经成功了，但是如果你有自己的HTML项目，该怎样让别人通过你的网址访问呢？</p>
<p>其实也很简单，将项目放到Tomcat目录下的<code>webapps</code>目录就行；访问的话就是<code>你的网址+项目的目录名+项目的名.html</code>，如我的一个就是<code>http://to.free.idcfengye.com/migong/index.html</code></p>
<p>这样就能让别人通过你的网址来访问你的项目了！</p>
]]></content>
      <categories>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>Ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法基础</title>
    <url>/archives/b797e99c.html</url>
    <content><![CDATA[<p>由于该博客的文章全部都是用markdown写的，所以就写一下MarkDown语法相关吧！<span id="more"></span></p>
<hr>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。</p>
<hr>
<p>Markdown 能被使用来撰写电子书，如：Gitbook。</p>
<p>当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</p>
<hr>
<p>教程网站：<a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown 教程 | 菜鸟教程</a></p>
<p>个人觉得好用的在线编辑网站：<a href="https://dillinger.io/">Online Markdown Editor - Dillinger, the Last Markdown Editor ever.</a></p>
<p>LaTex公式手册网站：<a href="https://www.zybuluo.com/codeep/note/163962#mjx-eqn-eqsample">LaTex 公式指导手册</a> </p>
<p>个人觉得好用的PC端MarkDown软件：<a href="https://www.typora.io/">Typora — a markdown editor, markdown reader.</a>  – （现在收费了，不过是买断制，如果喜欢可以购买正版！）</p>
<hr>
<p>结束！！</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg的简单使用</title>
    <url>/archives/d9d00a92.html</url>
    <content><![CDATA[<p>简单聊一聊<code>FFmpeg</code>的使用；</p>
<p>其有非常强大的功能：包括但不限于 视频采集功能、视频格式转换、视频抓图、给视频加水印等。</p>
<p><em>以下来源于百度百科：<code>FFmpeg</code>是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用<code>LGPL</code>或<code>GPL</code>许可证。它提供了录制、转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库<code>libavcodec</code>，为了保证高可移植性和编解码质量，<code>libavcodec</code>里很多<code>code</code>都是从头开发的。</em></p>
<span id="more"></span>

<hr>
<h3 id="简单介绍一下使用方法："><a href="#简单介绍一下使用方法：" class="headerlink" title="简单介绍一下使用方法："></a>简单介绍一下使用方法：</h3><h3 id="应用场景1：格式转换"><a href="#应用场景1：格式转换" class="headerlink" title="应用场景1：格式转换"></a>应用场景1：格式转换</h3><p>我想把用<code>iPhone</code>拍的<code>.MOV</code>文件转成<code>.avi</code>文件。最简单了，可以执行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i D:\Media\IMG_0873.MOV D:\Media\output.avi  </span><br></pre></td></tr></table></figure>

<p>【意思是，把<code>D:\Media</code>目录下的源文件<code>IMG_0873.MOV</code>（视频：<code>h.264</code>，音频：<code>aac</code>）转换成<code>output.avi</code>（编码格式自动选择为：视频<code>mpeg4</code>，音频<code>mp3</code>），目标文件仍然保存到<code>D:\Media</code>目录下。】</p>
<p>问题来了：我想自己指定编码格式，怎么办呢？可通过目标文件的扩展名（<code>.flv</code>、<code>.mpg</code>、<code>.mp4</code>、<code>.wmv</code>等）来控制，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i D:\Media\IMG_0873.MOV D:\Media\output2.flv</span><br></pre></td></tr></table></figure>

<h3 id="应用场景2：调整大小"><a href="#应用场景2：调整大小" class="headerlink" title="应用场景2：调整大小"></a>应用场景2：调整大小</h3><p>若源文件的图像帧尺寸是1920x 1080，我不需要这么大——能有720 x 480就够了。于是，就要用上<code>-s</code>参数了。为了保证图像缩放后的质量，最好加上码流参数<code>-b:v</code>。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i D:\Media\IMG_0873.MOV -s 720x480 -b:v 1500k D:\Media\output2.avi</span><br></pre></td></tr></table></figure>

<h3 id="应用场景3：翻转视频"><a href="#应用场景3：翻转视频" class="headerlink" title="应用场景3：翻转视频"></a>应用场景3：翻转视频</h3><p>手机拍的视频中，有些是颠倒的，我想让它顺时针旋转90度。这时候，可以使用<code>-vf</code>参数加入一个过滤器，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i D:\Media\IMG_0873.MOV -vf &quot;rotate=90*PI/180&quot; D:\Media\output3.avi</span><br></pre></td></tr></table></figure>

<p>注：如果想逆时针旋转90度，90前面加个负号就可以了。</p>
<h3 id="应用场景4：截取一段"><a href="#应用场景4：截取一段" class="headerlink" title="应用场景4：截取一段"></a>应用场景4：截取一段</h3><p>需要从源视频里截取一小段，怎么办呢？比如从第2秒的地方开始，往后截取10秒钟。命令行可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -ss 2 -t 10 -i D:\Media\IMG_0873.MOV D:\Media\output4.avi</span><br><span class="line">或</span><br><span class="line">ffmpeg -i ./input.mp4 -c:v libx264 -crf 18 -ss 00:00:10 -to 00:00:15 ./cut_out.mp4</span><br></pre></td></tr></table></figure>

<p>注：这种情况下，<code>-ss</code>和<code>-t</code>参数必须放在<code>-i</code>前面，表示是限定后面跟着的输入文件的。</p>
<h3 id="应用场景5：视频合成"><a href="#应用场景5：视频合成" class="headerlink" title="应用场景5：视频合成"></a>应用场景5：视频合成</h3><p>用手机拍的视频有时候背景噪音比较大。怎么把噪音去掉，换成一段美妙的音乐呢？使用<code>FFmpeg</code>也能轻易做到。</p>
<p><em><strong>第一步：</strong></em>把源文件里的音频去掉，生成一个临时文件<code>tmp.mov</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i D:\Media\IMG_0873.MOV -vcodec copy -an D:\Media\tmp.mov</span><br></pre></td></tr></table></figure>

<p>注：<code>-vcodec copy</code>的意思是对源视频不解码，直接拷贝到目标文件；<code>-an</code>的意思是将源文件里的音频丢弃。</p>
<p><em><strong>第二步：</strong></em>把这个无声的视频文件（<code>tmp.mov</code>）与一个音乐文件（<code>music.mp3</code>）合成，最终生成<code>output.mov</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i D:\Media\tmp.mov -ss 30 -t 52 -i D:\Media\music.mp3 -vcodec copy D:\Media\output5.avi</span><br><span class="line"></span><br><span class="line">ffmpeg.exe -i G:\test\removebgm.mp4 -ss 00:00:00.0 -t 00:03:31 -i G:\test\456.mp3 -acodec copy G:\test\hfdk.mp4</span><br></pre></td></tr></table></figure>

<p>为了保证良好的合成效果，音乐时长必须匹配视频时长。这里我们事先知道视频时长为52秒，于是截取<code>music.mp3</code>文件的第30秒往后的52秒与视频合成。另外，为了保证音频时长截取的准确性，我们这里没有使用<code>-acodec copy</code>，而是让音频重新转码。</p>
<p>还有一种情况：我们希望在一段视频上叠加一张图片（将视频画面全部显示该图片）。可以简单实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i D:\Media\IMG_0873.MOV -i D:\Media\logo.png -filter_complex   &#x27;overlay&#x27; D:\Media\output6.avi</span><br></pre></td></tr></table></figure>

<h3 id="应用场景6：视频播放"><a href="#应用场景6：视频播放" class="headerlink" title="应用场景6：视频播放"></a>应用场景6：视频播放</h3><p>格式转换或合成之后，我们需要试着播放一下。播放器的选择很多。这里顺手用<code>ffplay</code>工具也行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffplay -i D:\Media\output6.avi</span><br></pre></td></tr></table></figure>

<h3 id="应用场景7：获取视频信息"><a href="#应用场景7：获取视频信息" class="headerlink" title="应用场景7：获取视频信息"></a>应用场景7：获取视频信息</h3><p>有时候，我只是想看看这个视频文件的格式信息。可以用<code>ffprobe</code>工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffprobe -i D:\Media\IMG_0873.MOV</span><br></pre></td></tr></table></figure>

<h3 id="应用场景8：截取视频前3秒-并转化为gif"><a href="#应用场景8：截取视频前3秒-并转化为gif" class="headerlink" title="应用场景8：截取视频前3秒 并转化为gif"></a>应用场景8：截取视频前3秒 并转化为<code>gif</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -ss 00:00:01 -t 3 -i 123.mp4 -vf crop=iw:ih*2/3 -s 320x240 -r 7 456.gif</span><br></pre></td></tr></table></figure>

<p><code>ps: -ss 00：00：01</code>表示从视频第一秒开始截取  ;  <code>- t</code> 表示截图3秒钟的视频  ;   <code>-vf crop=iw:ih*2/3 </code>表示截取视频的部分区域，其中宽为视频宽度，高为原视频的2/3  ;    <code>-r 7</code>表示每秒帧率为7帧  ; </p>
<h3 id="应用场景9：把AVI里的音频保存成mp3文件"><a href="#应用场景9：把AVI里的音频保存成mp3文件" class="headerlink" title="应用场景9：把AVI里的音频保存成mp3文件"></a>应用场景9：把<code>AVI</code>里的音频保存成<code>mp3</code>文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i source_video.avi -vn -ar 44100 -acodec libmp3lame -ac 2 -ab 192K -f mp3 sound.mp3</span><br></pre></td></tr></table></figure>

<h3 id="应用场景10：分离视频音频流"><a href="#应用场景10：分离视频音频流" class="headerlink" title="应用场景10：分离视频音频流"></a>应用场景10：分离视频音频流</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg.exe -i G:\test\123.mp4 -f mp3 -vn G:\test\fgsiug.mp3</span><br></pre></td></tr></table></figure>

<h3 id="应用场景11：截取音频"><a href="#应用场景11：截取音频" class="headerlink" title="应用场景11：截取音频"></a>应用场景11：截取音频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -i demo.mp3 -ss 00:26 -to 01:16:43 -c copy demo1.mp3</span><br><span class="line">//从26秒截取到一小时16分43秒，并导出</span><br></pre></td></tr></table></figure>

<h3 id="应用场景12：拼接视频"><a href="#应用场景12：拼接视频" class="headerlink" title="应用场景12：拼接视频"></a>应用场景12：拼接视频</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -f concat -i filelist.txt -c copy output.mp4</span><br><span class="line">//需要在目录下创建一个filelist.txt文件，内容如下：</span><br><span class="line">file &#x27;1.mp4&#x27;</span><br><span class="line">file &#x27;2.mp4&#x27;</span><br><span class="line">file &#x27;3.mp4&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="应用场景13：添加封面"><a href="#应用场景13：添加封面" class="headerlink" title="应用场景13：添加封面"></a>应用场景13：添加封面</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ffmpeg -i output.mp4 -i cover.jpg -<span class="built_in">map</span> <span class="number">1</span> -<span class="built_in">map</span> <span class="number">0</span> -c copy -disposition:<span class="number">0</span> attached_pic -y output_1.mp4</span><br></pre></td></tr></table></figure>



<p><em>ps：以上来源于互联网以及<code>FFmpeg</code>官方文档</em></p>
<hr>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>附上<code>FFmpeg</code>官网链接：<a href="https://github.com/FFmpeg/FFmpeg">FFmpeg/FFmpeg: Mirror of https://git.ffmpeg.org/ffmpeg.git (github.com)</a></p>
]]></content>
      <categories>
        <category>FFmpeg</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>突然连接不了GitHub?</title>
    <url>/archives/d840bd6.html</url>
    <content><![CDATA[<p>前段时间开学了，比较忙就没空写博客了；不过就在我忙里偷闲抽空写的时候发现连接不了GitHub了，嗯？什么情况？<span id="more"></span></p>
<p>这是什么情况？不应该啊？我啥都没动咋就不行了？一连串的疑问在我脑中萦绕！</p>
<p>以下为报错的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (D:\MyBlog\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:400:28)</span><br><span class="line">      at ChildProcess.cp.emit (D:\MyBlog\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure>

<p>没办法，第一次遇到，上网搜解决办法吧！大部分的帖子都说ssh失效了，重新生成一下；好，我照做！但完全没效果是什么意思，是我不配了吗？难搞哦！最后想了想先放这儿吧，有空再好好收拾收拾你！</p>
<p>过了几天，我又屁颠屁颠地回来了；继续搞，我还就不信了！继续上网搜解决办法呗，但结果都大差不差，都让我重新生成ssh；可我都重新生成几遍了，还是不行，这怎搞？老规矩，先晾着，说不定哪天我试试他自己就好了！（<del>我在想peach</del>）</p>
<p>不过，这次我可没放着就不管了；我甚至走路都在想到底是哪里出问题了；后来仔细分析了一下，好像和家里的改变就只有地区的改变了！再深想一下，网络也随之改变了！嗯，一定是这个原因，死马当做活马医，试试吧！<strong>断开校园网，拔掉网线</strong>，换个手机热点看看！（<em>一定要拔掉网线，不要问我为什么会知道</em>）</p>
<p>没想到啊，没想到！结果真的出在这里，用手机热点后一下就连通了！！（话说，这是为什么呢？校园网端口没开放？那换个端口行不？我还没试过，有谁试了可以给我说一下哈！）</p>
<p>到这儿，文章就结束了；结果只是换个网络就行，整的那么复杂。还好我没想不开将博客删了重建！也算是一点经验吧！希望遇到这个问题的朋友看到这儿后可以完美解决！</p>
<hr>
<p>突然又想到福尔摩斯的一句名言：</p>
<blockquote>
<h4 id="排除一切不可能的，剩下的即使再不可能，那也是真相！-—-夏洛克·福尔摩斯"><a href="#排除一切不可能的，剩下的即使再不可能，那也是真相！-—-夏洛克·福尔摩斯" class="headerlink" title="排除一切不可能的，剩下的即使再不可能，那也是真相！  — 夏洛克·福尔摩斯"></a>排除一切不可能的，剩下的即使再不可能，那也是真相！<br><br>  — 夏洛克·福尔摩斯</h4></blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>精确搜索你需要的资料</title>
    <url>/archives/c485373b.html</url>
    <content><![CDATA[<h3 id="今天写写关于搜索的文章吧！"><a href="#今天写写关于搜索的文章吧！" class="headerlink" title="今天写写关于搜索的文章吧！"></a>今天写写关于搜索的文章吧！</h3><p>“搜索”如果用好了，你几乎可以搜到任何你要的资料，但前提是你得会搜哦！</p>
<p>以下是我常用的搜索小技巧，你可以参考参考。</p>
<span id="more"></span>

<hr>
<h3 id="1-将结果限定在某个网站中"><a href="#1-将结果限定在某个网站中" class="headerlink" title="1. 将结果限定在某个网站中"></a>1. 将结果限定在某个网站中</h3><p>实现这个操作并不难，用<code>site</code>指令即可；</p>
<p>如：我要搜知乎中关于 “人工智能” 的内容，就可以这样来表达：<code>人工智能  site:zhihu.com</code>，这样就能搜到知乎中所有有关人工智能的文章，还弥补知乎站内搜索效果差的缺陷。</p>
<h3 id="2-将结果限定为某种文件类型"><a href="#2-将结果限定为某种文件类型" class="headerlink" title="2. 将结果限定为某种文件类型"></a>2. 将结果限定为某种文件类型</h3><p>这个也不难理解，不过你得有明确的目标，知道你要搜索的文件类型；这种适合用来搜电子教材或文档；</p>
<p>如：我要搜 “2020考研数学真题”，就可以这样表示：<code>2020考研数学真题 filetype:pdf</code>，这样你搜到的就都是各大网站的PDF文件。</p>
<h3 id="3-限定搜索结果的时间范围"><a href="#3-限定搜索结果的时间范围" class="headerlink" title="3. 限定搜索结果的时间范围"></a>3. 限定搜索结果的时间范围</h3><p>你如果要搜比较新的内容，不想要时间久远的内容来徒增工作量，那么就能用得上这个指令了；</p>
<p>如：我要搜 “人工智能” 最前沿的资讯，就能这样写：<code>人工智能 2020..2021</code>，这样搜出来的基本就是2020年到2021年关于人工智能的信息了。当然，时间你可以随便更换。</p>
<h3 id="4-限定标题中必须包含的关键字"><a href="#4-限定标题中必须包含的关键字" class="headerlink" title="4. 限定标题中必须包含的关键字"></a>4. 限定标题中必须包含的关键字</h3><p>这个也很容易理解了</p>
<p>如：我要搜关于 “ AI ” 的文章，但标题中必须包含 “大数据”，就能这样写：<code>AI intitle:大数据</code>，这样搜到的 AI 信息就都是标题中带有 “大数据” 三个字的。</p>
<h3 id="5-限定结果网址中包含字段"><a href="#5-限定结果网址中包含字段" class="headerlink" title="5. 限定结果网址中包含字段"></a>5. 限定结果网址中包含字段</h3><p>如：我要搜腾讯的关于 “人工智能” 的网站，那么就能写为：<code>人工智能 inurl:tencent</code>，这样就能直接看到所有腾讯旗下关于人工智能的内容，不用再在浏览器中一页一页向下找。</p>
<h3 id="6-删除结果中你不想要的信息"><a href="#6-删除结果中你不想要的信息" class="headerlink" title="6. 删除结果中你不想要的信息"></a>6. 删除结果中你不想要的信息</h3><p>此指令可以删除搜索结果中不必要的信息；不过，我一般用来去掉广告、推广之类的。</p>
<p>如：我要搜 “人工智能学习” ，就能写为：<code>人工智能学习 -广告 -推广</code>，这样搜出来的没有广告，没有搜索引擎的推广，都是精华；不信你可以试试。</p>
<p>当然，这个指令不止可以用来去广告，你也可以开动你那聪明的小脑瓜，想想怎样用可以更加方便、快捷、高效。</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><table>
<thead>
<tr>
<th align="center">指令</th>
<th align="center">作用</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">site</td>
<td align="center">将结果限定在某个网站中</td>
<td align="center">见文中</td>
</tr>
<tr>
<td align="center">filetype</td>
<td align="center">将结果限定为某种文件类型</td>
<td align="center">见文中</td>
</tr>
<tr>
<td align="center">时间1..时间2</td>
<td align="center">限定搜索结果的时间范围</td>
<td align="center">见文中</td>
</tr>
<tr>
<td align="center">intitle</td>
<td align="center">限定标题中必须包含的关键字</td>
<td align="center">见文中</td>
</tr>
<tr>
<td align="center">inurl</td>
<td align="center">限定结果网址中包含字段</td>
<td align="center">见文中</td>
</tr>
<tr>
<td align="center">“ -“（减号）</td>
<td align="center">删除结果中你不想要的信息</td>
<td align="center">见文中</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>精确搜索</category>
      </categories>
      <tags>
        <tag>搜索技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌账号的注册</title>
    <url>/archives/c7047092.html</url>
    <content><![CDATA[<p>今天写一个关于国内注册谷歌账号的方法，防止自己忘记，也可给不会的朋友一点思路！</p>
<p>这些方法也是截止写这篇文章为止，我自己测试可用的！</p>
<span id="more"></span>

<p>注册的前提是，你有 “科学上网” 的方法；否则就算注册了也没用不是吗？另外，你还得安装谷歌框架，这个软件你可以点 <a href="https://yinzhen.lanzoui.com/iM4Bkutxnfa">这里</a> 下载。</p>
<p>这里我不提供该上网方法与软件，有兴趣自己搜！</p>
<p><strong>ps：文中环境为 “科学上网” 环境下！</strong></p>
<hr>
<h3 id="1-利用QQ邮箱"><a href="#1-利用QQ邮箱" class="headerlink" title="1. 利用QQ邮箱"></a>1. 利用QQ邮箱</h3><p>手机上下载QQ邮箱，在 “添加账户” 处选择 Gmail 邮箱，点击后会出现登录页面；你可以点击左下角的 “创建账号” 来进行注册，接着一步一步往下走就行。</p>
<h3 id="2-利用Gmail邮箱"><a href="#2-利用Gmail邮箱" class="headerlink" title="2. 利用Gmail邮箱"></a>2. 利用Gmail邮箱</h3><p>Gmail邮箱在各大软件商店都能下载，安装完成并打开后选择创建账户，一步一步往下即可，国内手机号是可以接到验证码的！</p>
<p>今天我刚用此方法注册了一个新的账号，可行！ </p>
<h3 id="3-利用OurPlay加速器"><a href="#3-利用OurPlay加速器" class="headerlink" title="3. 利用OurPlay加速器"></a>3. 利用OurPlay加速器</h3><p>该软件在各大应用商店也能下载，下载安装后，点击登录账户（此时没有创建账户这个选项，别急，往下看）；随便输入一个已经存在的账号【例如：aaaa666#gmail.com （将 # 改为 @ 即可）】，进入下一步输入密码；不是你的账号，你肯定不知道密码，所以点手机上的返回菜单（不要大返回桌面，返回上一步就行），这是你会发现在登录账户页面的左下角出现了 “创建账户” 的按钮；接着一步一步向下就行了。注册完成就能登录Gmail了，这时就可以将OurPlay加速器卸载了！（没错，卸磨杀驴😉）</p>
<h3 id="4-利用-Google-Chrome-浏览器"><a href="#4-利用-Google-Chrome-浏览器" class="headerlink" title="4. 利用 Google Chrome 浏览器"></a>4. 利用 Google Chrome 浏览器</h3><p>这个方法是我听别人说的，今天我测试了一下，没成功；但想到可能是我自己的原因，所以就写出来给大家看看，万一你们可以呢，对吧！</p>
<p>将PC端 Google Chrome 浏览器语言设置为英文，重启浏览器；然后打开页面进行注册，按部就班地往下即可。</p>
<hr>
<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>注册完成后，不要频繁更换代理IP，有可能会被封，就这样。</p>
]]></content>
      <categories>
        <category>谷歌</category>
      </categories>
      <tags>
        <tag>谷歌</tag>
      </tags>
  </entry>
  <entry>
    <title>解析Freenom域名</title>
    <url>/archives/79444b31.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​        前几天刚用 github + hexo 搭建了一个博客，用来记录自己的学习成果！但域名是 github 的二级域名，看着不太好看；就寻思怎样白嫖一个域名；<span id="more"></span>搜来搜去，看到了一个帖子说可以去 freenom 白嫖，就想着试试；结果自己根本搞不了，无奈继续搜教程呗！看了好多教程，都没成功；想来想去就上 Youtube 了，按时间排序，第一个就是；真是保姆级的教程，一次成功，哈哈！视频链接我放这儿了，有需自取：<a href="https://www.youtube.com/watch?v=dTVKfuW9BiU">白嫖freenom域名</a></p>
<p>​        白嫖成功了，自然要用起来，不然费那么大劲干什么！其实我之前是有买过域名和服务器的，但感觉有一丢丢贵，就没续费了；但那是在阿里云买的，域名解析和现在的情况完全不同；没办法，就又双叒上网搜教程，还是找了好多，搜索的姿势也换了好多，终于还是让我找到了，难呐！（该说不说，搞这个也许代码功夫没长进，搜索资源的心得倒是攒了一大堆！）于是又是一波操作，现在弄成功了，域名是 totoro933.tk ，不出意外应该之后的很长一段时间都有效，若是打不开了，或者打开后不是我的博客，就说明被回收了（免费的还是有弊端的，有条件还是自己买个吧）。好了，接下来我会将我踩的坑分享一下，有需要的可要好好看了！</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>​        有一个域名，也可以和我一样去 freenom.com 白嫖（教程在上边）</p>
<p>​        注册好并实名认证 Dnspod ，官网地址：<a href="https://console.dnspod.cn/">Dnspod官网</a></p>
<h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>​        其实在 freenom 买过域名后，它本就提供了 DNS 解析服务，但因为 freenom 的 DNS 解析在国内可能不是很流畅，所以我才会选用 Dnspod （这是腾讯家的网站）；在解析之前，我们要把这个域名的控制权从 freenom 交到 Dnspod 的手上：打开 Dnspod 主页，在侧栏中选择“我的域名”，点击添加域名，把你的域名填进去，如 我的就是：totoro933.tk ，点击确定；接着往下，他会给你两个 dns server 地址，将其填到 freenom 中，具体流程为：</p>
<blockquote>
<p>登陆freenom，从首页点击 services -&gt; my domain -&gt; manage domain -&gt; Management Tools -&gt; Nameservers -&gt; Use custom nameservers (enter below) -&gt; 在前两个空中填入 Dnspod 给你的两个的 dns server 地址，最后点击最下边的提交按钮就好了。</p>
<p>如果你找不到 My domain ， 请确认你是不是登录了。</p>
</blockquote>
<p>​        完成上述步骤后，打开你的 Dnspod 主页，找到你刚才添加的域名，点击它，你会跳到添加解析度页面，点击添加记录，<em>主机记录</em> 一栏填<code>www</code>，<em>记录类型</em> 填<code>A</code>，<em>线路类型</em> 为默认，<em>记录值</em> 填 ping xxxx.github.io后所得到的IP地址，其中xxxx为你的 github 仓库名，后边的默认就行，点击确定；然后再点击快速添加解析，选择“域名映射(CNAME)”，填入xxxx.github.io，确定即可！到这里，DNS解析已经完成了。<strong>（注意：有时候 DNS 的设置不是即时生效的，不同地方需要不同的时间，有时候几分钟就好了，有时候要一晚上一天，设置好后可以美美的睡一觉，第二天应该就没问题了！）</strong></p>
<h3 id="设置github"><a href="#设置github" class="headerlink" title="设置github"></a>设置github</h3><p>​        进入 github 你托管博客的那个项目，按顺序依次点<code>setting -&gt; GitHub Pages -&gt; Custom domain</code>， 输入你的域名，如 我的为：totoro933.tk，点 save 。</p>
<h3 id="增加-CNAME-文件"><a href="#增加-CNAME-文件" class="headerlink" title="增加 CNAME 文件"></a>增加 CNAME 文件</h3><p>​        在你存放博客的根目录的 <code>source</code> 文件夹下新建一个文件  <code>CNAME </code>，注意，它没有后缀，就叫 CNAME ，文件内容填你的域名！</p>
<h3 id="修改-config-文件"><a href="#修改-config-文件" class="headerlink" title="修改 _config 文件"></a>修改 _config 文件</h3><p>​        去你 blog 的根目录下，修改 _config.yml 文件：打开后搜 skip ，你会看到 <code>skip_render:</code>，然后在后边添加<code>CNAME</code>，注意，在CNAME前有个空格！！！</p>
<p>​        然后保存，之后就能通过你的域名来访问你的博客了；如果没生效的话，可以先进行一波</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>​        然后就能愉快的访问了！</p>
]]></content>
      <categories>
        <category>Freenom</category>
        <category>域名</category>
      </categories>
      <tags>
        <tag>Freenom</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/archives/f3fb008f.html</url>
    <content><![CDATA[<blockquote>
<h4 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h4><p>我的第一篇博客，关于博客搭建的（hexo + github），记录搭建过程以及我踩过的坑！</p>
<p>有兴趣可以点开看看哦！</p>
</blockquote>
<span id="more"></span>

<hr>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li>安装 git</li>
<li>安装 node.js</li>
<li>安装 hexo</li>
<li>注册一个 github 账号</li>
<li>搭建仓库</li>
<li>生成SSH Keys</li>
<li>生成博客内容</li>
<li>发布博客至互联网</li>
</ol>
<hr>
<h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>​    首先，我们先来了解一下什么是 git；简单来说 git 是开源的分布式版本控制系统，用于敏捷高效地处理项目。我们网站在本地搭建好了，需要使用 git 同步到 GitHub 上。这里，我们就不多说了！</p>
<p>​    附上 git 官网地址：<a href="https://git-scm.com/">git官网</a></p>
<p>​    去官网下载适合自己电脑的版本，下一步，下一步跟着安装即可！我这里提供个教程，仅供参考！<a href="https://blog.csdn.net/ssd21988/article/details/107826076">git安装教程</a>  步骤可能有些不一样，不过一般都按默认即可。</p>
<p>安装完成后，我们可以测试一下安装成功与否：按键盘上 win + R 键，输入 cmd ，打开命令提示符窗口，接着输入 <code>git --version</code> ，看其是否出现版本号；如下图：</p>
<p><img src="https://s2.loli.net/2024/07/12/sn7HMNDolVeBwKk.jpg"></p>
<p>​    如果出现，那么恭喜你，安装成功！（如果命令提示符上没有可以重启电脑后再次查看或在git上查看）</p>
<p>​    这时候你会发现，鼠标右击后会出现两个新的菜单 <code>Git GUI Here</code> 和 <code>Git Bash Here</code>，我们平时只会用到后者，不要搞错了！</p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>​    因为，我们的博客是基于 hexo 的，而 hexo 又是基于 node.js 的，所以这是必不可少的！</p>
<p>​    我们可以去其<a href="http://nodejs.cn/download/">官网</a>，下载并安装；也是直接下一步、下一步就行；这里我也放个教程，可以参考一下：<a href="https://blog.csdn.net/antma/article/details/86104068">node.js 安装详细步骤教程</a>；不过，值得注意的是：安装 node.js 会包含环境变量及 npm 的安装</p>
<p>​    安装好以后，我们要检测 node 与 npm 是否安装成功：按键盘上 win + R 键，输入 cmd ，打开命令提示符窗口，分别输入 <code>node -v</code> ，<code>npm -v</code> 看其是否出现版本号；</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>​    hexo 就是我们的个人博客网站的框架；安装的话也很简单，按键盘上 win + R 键，输入 cmd ，打开命令提示符窗口，输入<code>npm install -g hexo-cli </code>，进行安装hexo，等待安装好后，我们检验其是否安装成功输入<code>hexo -v</code>看是否出现版本号；如下图：</p>
<p><img src="https://s2.loli.net/2024/07/12/uZSAWjHx3JCBndT.jpg"></p>
<p>如果安装不成功（前提是按照<a href="https://blog.csdn.net/antma/article/details/86104068">node.js 安装详细步骤教程</a>的步骤来进行）那么可以按照<a href="https://blog.csdn.net/fuyuanduan/article/details/128750582">此方法</a>来进行设置，给完权限后再次执行安装hexo的命令即可安装成功了！</p>
<h3 id="注册github"><a href="#注册github" class="headerlink" title="注册github"></a>注册github</h3><p>​    我们打开<a href="https://github.com/">github官网</a>，然后点右上角的Sign up，即可注册，其实也很简单；这里还是提供一篇教程，不会的可以看看：<a href="https://www.bilibili.com/read/cv5107169">github注册教程</a>，<strong>注意：一定要记住注册名、注册邮箱和注册密码哦！!</strong></p>
<blockquote>
<p>至此，我们的准备工作就做完了，接下来就是实操时间！</p>
</blockquote>
<hr>
<h3 id="搭建仓库"><a href="#搭建仓库" class="headerlink" title="搭建仓库"></a>搭建仓库</h3><p>​    注册完账号后登陆，点击右上角的 + 号，选择 New repository  ；然后，仓库名字填你的注册名 + <code>.github.io</code>，例如我的就是 <code>seatoro.github.io</code>，之后的 Description 可填可不填； 接下来选择 Public ，否则别人访问不了你的博客！然后把 Add a README file 勾上；最后，点击最下边的 Create repository 的按钮就能创建好你的仓库了！如下图：</p>
<p><img src="https://s2.loli.net/2024/07/12/BAeQ2Smnj1h94Tx.jpg"></p>
<h3 id="生成SSH-Keys"><a href="#生成SSH-Keys" class="headerlink" title="生成SSH Keys"></a>生成SSH Keys</h3><p>​    我们可以在合适的盘新建一个文件夹，可以命名为MyBlog，hexo 框架与以后你自己发布的网页都会在这个文件夹中。一定要记住路径哦，别之后找不到了！打开这个文件夹，鼠标右键，点击 <code>Git Bash Here</code>，然后我们就会进入一个黑框框页面；直接输入 <code>SSH</code> ，来检测我们是否装有SSH，其实默认是装过的！然后输入 <code>ssh-keygen -t rsa -C &quot;你注册github的邮件地址&quot;</code>。之后敲4次回车键（<strong>注意：不是连着敲，敲一次，等里面的内容不再变化后再敲下一次！</strong>）最后，你会看到一个用短线组成的框框，到这儿你就成功了！不要关闭这个窗口，一会还要用！！</p>
<p>​    按 Win + E 打开文件资源管理器，打开C盘 –&gt; 用户文件夹 –&gt; 个人文件夹 –&gt; .ssh文件夹，进入后我们可以看到里面有两个文件，用文本编辑器打开名为 <code>id_rsa.pub</code>的文件，<code>ctrl + a</code> <code>ctrl + c</code>复制里面的全部内容！</p>
<p>​    打开 github ，点击右上角头像找到 Setting ，点进去，往下划在左侧栏找到 SSH and GPG keys，点进去，第一个就是SSH Keys，点击 New SSH Key ，Title 随便填如：MyBlog；Key 就填你刚才复制 id_rsa.pub 里的一大串内容，（以你的邮箱结尾）；点 Add SSH Key 按钮即可。</p>
<p>​    测试是否绑定成功：在刚刚到黑框中输入 <code>ssh -T git@github.com</code>，敲回车，再输入 yes 敲回车即可，只要出现<code>Hi 你的github用户名</code>，就说明成功了！</p>
<h3 id="生成本地博客内容"><a href="#生成本地博客内容" class="headerlink" title="生成本地博客内容"></a>生成本地博客内容</h3><p>​    进入你在上一步中创建的文件夹，在空白处右键，点击 <code>Git Bash Here</code>，在出现的黑框中输入 <code>hexo init</code>来初始化我们的hexo，等待执行完成（如果出现错误，可多尝试几次），成功的标志：<code>INFO Start blogging with Hexo!</code>，这时我们打开上一步中创建的文件夹就会发现里面多了很多内容！</p>
<p>​    继续在黑框中敲命令：<code>hexo s</code>，启动本地服务器，看到出现 <code>http://localhost:4000</code>后就大功告成，接着我们只需要复制这个地址，去浏览器打开，就能看到我们的博客了；关闭服务器的话只需按 <code>ctrl + c</code>（没错就是复制的快捷键）就能关闭了，关闭后浏览器就打不开你的博客了！</p>
<h3 id="发布博客至互联网"><a href="#发布博客至互联网" class="headerlink" title="发布博客至互联网"></a>发布博客至互联网</h3><p>​    进入你在上上一步中创建的文件夹，找到<code>config.yml</code>文件（注意：没有扩展名是因为你没有开启这个功能，开启方法<a href="https://jingyan.baidu.com/article/f00622282564bdfbd3f0c827.html">点这儿</a> ）并用文本编辑器打开，找到最后几行更改为下图所示。（<strong>注意：最后一行要空出来，即branch: main 后面要空一行；每个冒号后面有一个空格</strong>）另，repo后面的内容把我的用户名（seatoro）改为你自己的！！保存，退出即可。</p>
<p><img src="https://s2.loli.net/2024/07/12/qi1TzakEo74xWfe.jpg"></p>
<p>​    进入你的博客文件夹，在空白处右键，点击 <code>Git Bash Here</code>，在出现的黑框中输入 <code>npm install hexo-deployer-git --save</code>，安装 hexo-deployer-git ；安装成功后接着敲命令<code>hexo g</code>，回车；执行完后接着敲 <code>hexo d</code>，这个命令是发布网页至服务器中的！（如若出错，多试几次）这时需要验证你的github账号，用户名，就是github用户名，密码就不是你设置的密码了；我们打开github，点击右上角头像找到 Setting ，点进去，往下划在左侧栏找到 Developer settings，点进去，在左侧栏找到 Personal access tokens ，点进去，Note 随便填，Expiration 默认30天就行，下边的复选框全部勾上，最后点击 Generate token 按钮生成令牌。复制生成的令牌，它只会出现一次，一定要记好；将复制的内容粘贴到刚才的密码框中点击 OK 就行了！这时就将本地内容上传到 github 中了，然后你就能通过网址访问了，网址就是你 github 主页左上角的网址，如下：</p>
<p><img src="https://s2.loli.net/2024/07/12/miawLHGdNXhAC3c.jpg"></p>
<hr>
<p>​    至此，hexo + github 搭建博客就算是成功了，恭喜！！</p>
<p>​    不过这只是最初的内容，其实还有好多内容，比如：怎样美化你的博客、更换主题；怎样添加各种小功能；怎样新建、删除文章；怎样搭建自己的图床等等！</p>
<p>​    但我实在是不想写了，写教程太累了，😭  看情况，之后有时间再补充吧！如果在搭建过程中遇到了问题，可以将错误内容复制到百度，搜一下，你肯定会看到解答的；因为你肯定不是第一个遇到问题的人，如果没有搜到，只能说，你搜索的姿势不对，可以考虑换个姿势再来一次，哈哈哈！</p>
<p>​    就这样吧！！</p>
]]></content>
      <categories>
        <category>Hexo</category>
        <category>Github</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/archives/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new My New Post</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<span id="more"></span>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
